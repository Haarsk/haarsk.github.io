<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Professional Screen Light | SLE V8.5 Optimized</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Orbitron:wght@500;900&family=Black+Ops+One&display=swap" rel="stylesheet">
 
    <script src="presets.js"></script>
    <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "c5c00e171f1d4a658a383cb6c76d7ec2"}'></script><!-- End Cloudflare Web Analytics -->
<style>
        /* CORE VARIABLES */
        :root { 
            --panel-bg: rgba(10, 15, 10, 0.98); 
            --accent: #f5a623; 
            --text: #e0e0e0; 
            --danger: #ff0000; 
            --success: #00ff00; 
            --lcd-bg: #001100; 
            --lcd-off: #003300; 
            --lcd-on: #33ff33; 
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Roboto Mono', monospace; color: var(--text); user-select: none; -webkit-user-select: none; overscroll-behavior: none; }

        /* LAYERS */
        #light-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; image-rendering: pixelated; }
        #text-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: auto; }

        /* STARTUP OVERLAY */
        #startup-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 10000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; transition: opacity 0.5s ease-out; backdrop-filter: blur(10px);
        }
        
        .intro-lang-bar {
            display: flex; gap: 15px; margin-bottom: 20px; z-index: 10001;
            flex-wrap: wrap; justify-content: center;
        }
        .intro-lang-btn {
            font-family: 'Orbitron'; font-size: 14px; color: #004400; 
            border: 1px solid #004400; background: #001100; padding: 5px 10px; 
            cursor: pointer; border-radius: 4px; transition: 0.2s; font-weight: bold;
        }
        .intro-lang-btn:hover { color: #fff; border-color: #fff; transform: scale(1.1); }
        .intro-lang-btn.active { color: var(--lcd-on); border-color: var(--lcd-on); box-shadow: 0 0 10px var(--lcd-on); background: #002200; }

        .startup-box {
            background: var(--panel-bg); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            border: 1px solid #333; border-radius: 12px;
            width: 95%; max-width: 600px; height: 95vh; max-height: 950px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 40px; text-align: center;
            box-shadow: 0 40px 100px #000;
            pointer-events: none; 
            position: relative;
        }
        .startup-box::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 5px; background: linear-gradient(90deg, #004400, var(--lcd-on), #004400); opacity: 0.5; }
        .startup-box::after { content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px; background: #004400; }

        .startup-title {
            font-family: 'Orbitron'; font-size: 24px; color: var(--lcd-on);
            margin-bottom: 30px; font-weight: 900; letter-spacing: 2px;
            text-shadow: 0 0 15px var(--lcd-on); text-transform: uppercase;
        }
        .startup-text {
            font-family: 'Roboto Mono'; font-size: 14px; color: #e0e0e0;
            line-height: 1.8; margin-bottom: 50px; text-align: justify;
            max-width: 90%;
        }
        .startup-hint {
            font-family: 'Orbitron'; font-size: 12px; color: #888;
            animation: pulse 1s infinite alternate; letter-spacing: 1px;
            border: 1px solid #444; padding: 10px 20px; border-radius: 4px; background: #000;
        }

        /* MAIN PANEL */
        .control-panel {
            position: absolute; pointer-events: auto; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--panel-bg); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            border: 1px solid #333; border-radius: 12px; width: 95%; max-width: 600px; height: 95vh; max-height: 950px;
            display: flex; flex-direction: column; box-shadow: 0 40px 100px #000; overflow: hidden; transition: opacity 0.3s, transform 0.3s; z-index: 2000;
        }
        .control-panel.hidden { opacity: 0; pointer-events: none; transform: translate(-50%, -50%) scale(0.9); }
        
        @media (max-width: 768px) {
            .control-panel { width: 100%; height: 100dvh; max-width: none; max-height: none; top: 0; left: 0; transform: none; border-radius: 0; border: none; }
            .startup-box { width: 100%; height: 100dvh; max-width: none; max-height: none; border-radius: 0; border: none; border-bottom: 2px solid var(--lcd-on); }
            .control-panel.hidden { transform: translateY(100%); opacity: 0; }
            .drag-bar { display: none !important; }
            .panel-header { padding: 5px 10px; height: 45px; }
            .startup-box { padding: 20px; }
            .startup-title { font-size: 20px; }
            .startup-text { font-size: 12px; }
            .intro-lang-bar { margin-top: 20px; }
            .wheel-wrapper { min-height: 70px !important; }
            .wheel-container { width: min(100px, 17vh) !important; height: min(100px, 17vh) !important; }
        }

        /* SCROLLBAR */
        .panel-content::-webkit-scrollbar { width: 8px; }
        .panel-content::-webkit-scrollbar-track { background: #0a1a0a; border-left: 1px solid #333; }
        .panel-content::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; border: 1px solid #000; }
        .panel-content::-webkit-scrollbar-thumb:hover { background: var(--lcd-on); }

        /* HEADER */
        .drag-bar { height: 15px; background: linear-gradient(to bottom, #1a2a1a, #0a1a0a); border-bottom: 1px solid #004400; cursor: grab; display: flex; justify-content: center; align-items: center; flex-shrink: 0; }
        .drag-bar:active { cursor: grabbing; }
        .grip-lines { width: 50px; height: 100%; background-image: repeating-linear-gradient(90deg, transparent, transparent 2px, #005500 2px, #005500 3px); opacity: 0.5; }
        .panel-header { 
            display: flex; justify-content: space-between; align-items: center; 
            padding: 0 15px; background: #051105; border-bottom: 1px solid #004400; 
            flex-shrink: 0; height: 50px; 
        }
        .app-title { font-family: 'Orbitron'; font-weight: 900; font-size: 14px; letter-spacing: 1px; color: var(--lcd-on); text-shadow: 0 0 5px var(--lcd-on); margin-right: auto; }
        
        .header-controls { display: flex; align-items: center; }
        .lang-icon { font-size: 18px; margin-right: 10px; cursor: pointer; text-shadow: 0 0 5px #0f0; transition: transform 0.2s; position: relative; }
        .lang-icon:hover { transform: scale(1.2); }
        
        #lang-menu { position: absolute; top: 40px; right: 100px; background: #002200; border: 1px solid #0f0; border-radius: 4px; display: none; flex-direction: column; z-index: 3000; box-shadow: 0 5px 15px rgba(0,0,0,0.8); }
        #lang-menu.show { display: flex; }
        .lang-option { padding: 8px 15px; color: #fff; font-family: 'Orbitron'; font-size: 10px; cursor: pointer; border-bottom: 1px solid #004400; text-align: left; }
        .lang-option:hover { background: #004400; color: #0f0; }

        .header-preview-box { 
            height: 46px; width: 82px; background: #000; 
            border: 1px solid #00ff00; border-radius: 3px; margin-right: 10px; 
            cursor: pointer; overflow: hidden; 
        }
        #preview-canvas { width: 100%; height: 100%; display: block; object-fit: contain; }
        
        .hide-btn { 
            width: 82px; height: 46px; display: flex; justify-content: center; align-items: center; padding: 0;
            background: #002200; border: 1px solid #005500; color: #00aa00; 
            font-family: 'Orbitron'; font-size: 10px; font-weight: bold; 
            border-radius: 3px; cursor: pointer; 
        }

        /* TABS */
        .tabs { display: flex; background: #051105; flex-shrink: 0; border-bottom: 1px solid #004400; overflow-x: auto; height: 36px; }
        .tabs::-webkit-scrollbar { display: none; }
        .tab-btn { flex: 1; padding: 0 5px; min-width: 50px; background: transparent; border: none; color: #006600; font-family: inherit; font-weight: bold; font-size: 10px; cursor: pointer; border-bottom: 3px solid transparent; border-top: 3px solid transparent; transition: 0.2s; white-space: nowrap; }
        .tab-btn.active { color: var(--lcd-on); text-shadow: 0 0 3px var(--lcd-on); border-bottom: 3px solid var(--lcd-on); border-top: 3px solid var(--lcd-on); background: #002200; }

        /* CONTENT & CONTROLS */
        .panel-content { flex: 1; padding: 15px; display: none; flex-direction: column; overflow-y: auto; background: #020a02; min-height: 0; }
        .panel-content.visible { display: flex; }

        .control-group { margin-bottom: 12px; flex-shrink: 0; }
        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 9px; color: #00aa00; font-weight: bold; font-family: 'Orbitron'; }
        
        .lcd-input {
            background: var(--lcd-bg); color: var(--lcd-on);
            font-family: 'Orbitron', monospace; font-size: 10px;
            padding: 2px 6px; border-radius: 2px; border: 1px solid #004400;
            box-shadow: inset 0 0 5px rgba(0, 255, 0, 0.2);
            width: 50px; text-align: right; letter-spacing: 1px;
            -moz-appearance: textfield; 
        }
        .lcd-input::-webkit-outer-spin-button, .lcd-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .lcd-input:focus { outline: 1px solid var(--lcd-on); background: #002200; }

        .color-r { color: #ff3333 !important; border-color: #ff3333 !important; text-shadow: 0 0 2px #500; }
        .color-g { color: #33ff33 !important; border-color: #33ff33 !important; text-shadow: 0 0 2px #050; }
        .color-b { color: #3388ff !important; border-color: #3388ff !important; text-shadow: 0 0 2px #005; }

        input[type=range] { 
            -webkit-appearance: none; width: 100%; background: transparent; margin: 0; touch-action: none; display: block; height: 24px; cursor: pointer; 
            border: 1px solid var(--lcd-on); background-color: var(--lcd-bg); border-radius: 2px; box-shadow: 0 0 5px rgba(51, 255, 51, 0.1); padding: 0; 
            background-repeat: no-repeat; 
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 100%; background: transparent; border: none; }
        input[type=range]::-webkit-slider-thumb { 
            -webkit-appearance: none; height: 100%; width: 10px; background: var(--lcd-on); border: 1px solid #fff; 
            border-radius: 1px; margin-top: 0; box-shadow: 0 0 8px var(--lcd-on); 
        }
        #input-r { border-color: #ff3333; } #input-r::-webkit-slider-thumb { background: #ff3333; box-shadow: 0 0 8px #ff3333; }
        #input-g { border-color: #33ff33; } #input-g::-webkit-slider-thumb { background: #33ff33; box-shadow: 0 0 8px #33ff33; }
        #input-b { border-color: #3388ff; } #input-b::-webkit-slider-thumb { background: #3388ff; box-shadow: 0 0 8px #3388ff; }
        #input-white-r { border-color: #ff3333; } #input-white-r::-webkit-slider-thumb { background: #ff3333; box-shadow: 0 0 8px #ff3333; }
        #input-white-g { border-color: #33ff33; } #input-white-g::-webkit-slider-thumb { background: #33ff33; box-shadow: 0 0 8px #33ff33; }
        #input-white-b { border-color: #3388ff; } #input-white-b::-webkit-slider-thumb { background: #3388ff; box-shadow: 0 0 8px #3388ff; }
        
        .modifier-slider.active input[type=range] { box-shadow: 0 0 10px var(--lcd-on); }

        /* BUTTONS */
        .momentary-btn {
            background: #002200; color: #00aa00; border: 1px solid #005500;
            font-family: 'Orbitron'; font-weight: bold; cursor: pointer; border-radius: 3px; 
            font-size: 10px; text-transform: uppercase; transition: 0.1s;
        }
        .momentary-btn:hover { background: #003300; color: #fff; }
        .momentary-btn:active { 
            background: #00ff00 !important; color: #000 !important; border-color: #fff !important; 
            box-shadow: 0 0 15px #00ff00 !important; transform: scale(0.98);
        }
        .momentary-btn.mem-stored {
            color: #00ff00 !important;
            text-shadow: 0 0 8px #00ff00;
            border-color: #005500;
            box-shadow: inset 0 0 5px rgba(0, 255, 0, 0.2);
        }

        .preset-btn { 
            flex: 1; border: 1px solid #444; color: #000; 
            padding: 10px 0; border-radius: 4px; font-size: 12px; font-weight: 900; 
            cursor: pointer; text-align: center; min-width: 50px; transition: 0.2s;
            font-family: 'Orbitron'; box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .k2700 { background-color: #ffb46b; } .k3200 { background-color: #ffd1a3; } .k4300 { background-color: #ffebd1; }
        .k5600 { background-color: #ffffff; } .k6500 { background-color: #cfe7ff; }

        .preset-btn:hover { filter: brightness(1.2); }
        .preset-btn.active { border: 2px solid #00ff00; box-shadow: 0 0 15px #00ff00, inset 0 0 5px #fff; transform: scale(1.05); z-index: 10; }

        .activate-btn { width: 100%; padding: 8px; margin-top: 8px; font-size: 11px; flex-shrink: 0; }
        .recall-btn { width: 100%; padding: 6px; margin-top: 8px; font-size: 10px; flex-shrink: 0; }
        .memory-save-btn { flex: 1; font-size: 8px; }
        .live-save-btn { flex: 1; font-size: 8px; transition: background 0.1s; }
        .live-save-btn.saving-red { background: #ff0000 !important; color: #fff !important; box-shadow: 0 0 15px #ff0000 !important; border-color: #fff !important; }
        .blackout-btn { background: #300; color: #700; border: 1px solid #500; flex: 1.2; }
        .blackout-btn.active { background: var(--danger); color: white; border-color: #fff; box-shadow: 0 0 10px var(--danger); animation: pulse 0.5s infinite alternate; }
        
        .fullscreen-btn { background: #002200; color: #050; border: 2px solid #050; flex: 1; transition: background 0.2s, color 0.2s; }
        .fullscreen-btn.active { background: #006600 !important; color: #fff !important; border-color: #00ff00 !important; box-shadow: 0 0 15px #00ff00; text-shadow: 0 0 5px #fff; }
        
        @keyframes blink-3-times {
            0%, 100% { background-color: #002200; border-color: #050; color: #050; }
            50% { background-color: #00ff00; border-color: #fff; color: #000; box-shadow: 0 0 20px #00ff00; }
        }
        .blink-trigger { animation: blink-3-times 0.4s 3 forwards; }

        .presets-row { display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap; }
        @keyframes pulse { from { opacity: 1; } to { opacity: 0.7; } }

        /* MODULES (Wheel, RGB, Memory) */
        .wheel-wrapper { flex: 1; display: flex; align-items: center; justify-content: center; min-height: 140px; transition: background-color 0.1s ease; }
        .wheel-container { position: relative; width: min(200px, 35vh); height: min(200px, 35vh); border-radius: 50%; background: conic-gradient(red, yellow, lime, cyan, blue, magenta, red); box-shadow: inset 0 0 30px rgba(0,0,0,0.4), 0 0 10px #000; cursor: crosshair; touch-action: none; border: 15px solid #000; }
        .wheel-container::after { content: ''; position: absolute; top:0; left:0; width:100%; height:100%; border-radius: 50%; background: radial-gradient(circle, white 0%, transparent 70%); pointer-events: none; }
        .wheel-cursor { position: absolute; width: 14px; height: 14px; border: 2px solid #000; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; box-shadow: 0 0 5px #000; }
        .rgb-section { margin-top: 10px; }
        .hex-input { width: 100%; text-align: center; font-family: 'Roboto Mono'; font-weight: bold; font-size: 14px; background: #002200; color: var(--lcd-on); padding: 6px; margin-top: 4px; border-radius: 2px; border: 1px solid #005500; text-transform: uppercase; margin-bottom: 10px; letter-spacing: 2px; }

        .memory-section { margin-top: auto; padding-top: 10px; flex-shrink: 0; }
        .memory-label { font-size: 8px; color: #008800; text-align: center; margin-bottom: 4px; font-family: 'Orbitron'; }
        .memory-row { display: flex; gap: 6px; justify-content: space-between; height: 60px; }
        .memory-slot { flex: 1; display: flex; flex-direction: column; height: 100%; position: relative; }
        .memory-display-box { width: 100%; height: 100%; border: 1px solid #004400; border-radius: 4px; cursor: pointer; background: #001100; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); transition: border-color 0.2s; }
        .memory-display-box:active { border-color: #fff; transform: scale(0.98); }
        
        /* NOUVEAU BOUTON SAVE GLOBAL */
        .global-save-btn { height: 100%; width: 100%; border-color: #f5a623; color: #f5a623; font-size: 10px; border-radius: 4px; background: #002200; border-style: solid; border-width: 1px; font-family: 'Orbitron'; font-weight: bold; cursor: pointer; }
        .global-save-btn.saving-red { background: #ff0000 !important; color: #fff !important; border-color: #fff !important; box-shadow: 0 0 15px #ff0000; animation: pulse 0.5s infinite alternate; }
        
        /* LIVE PAGE */
        .live-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; flex: 1; overflow-y: auto; padding: 5px; align-content: start; }
        .live-slot { display: flex; flex-direction: column; gap: 2px; aspect-ratio: 1/1; position: relative; }
        .live-pad { flex: 4; background: #001100; border: 1px solid #004400; border-radius: 4px; cursor: pointer; box-shadow: inset 0 0 10px rgba(0,0,0,0.8); position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        .live-pad::after { content: ''; position: absolute; top:0; left:0; right:0; bottom:0; border: 1px solid transparent; transition: 0.2s; pointer-events: none; }
        .live-pad:active { transform: scale(0.98); border-color: #fff; }
        .live-pad.active-preset { border: 2px solid #33ff33 !important; box-shadow: 0 0 25px #33ff33, inset 0 0 5px #33ff33 !important; z-index: 50; }
        .pad-video { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; pointer-events: none; }
        .empty-pad-text { font-size: 8px; color: #003300; font-family: 'Orbitron'; pointer-events: none; }

        /* FX GRIDS */
        .fx-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; flex: 1; overflow-y: auto; padding-right: 2px; align-content: start; min-height: 0; }
        .fx-card { background: #001a00; border: 1px solid #003300; border-radius: 4px; padding: 0; text-align: center; cursor: pointer; height: 35px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #008800; }
        .fx-card span { font-size: 11px; font-weight: bold; text-transform: uppercase; line-height: 1; pointer-events: none; }
        .fx-card.active { background: var(--lcd-on); color: #000; border-color: var(--lcd-on); box-shadow: 0 0 10px var(--lcd-on); }
        .palette-container { display: flex; gap: 4px; justify-content: space-between; background: #051105; padding: 4px; border-radius: 4px; border: 1px solid #004400; margin-top: 4px; flex-shrink: 0; }
        .palette-item { display: flex; flex-direction: column; gap: 2px; align-items: center; flex: 1; cursor: pointer; }
        .palette-toggle { width: 100%; height: 6px; background: #002200; border: 1px solid #004400; border-radius: 2px; pointer-events: none; }
        .palette-toggle.active { background: #0f0; border-color: #0f0; box-shadow: 0 0 4px #0f0; }
        .palette-display { width: 100%; height: 16px; border-radius: 2px; border: 1px solid #004400; pointer-events: none; }

        /* MATRIX */
        .matrix-section { flex: 1; display: flex; flex-direction: column; gap: 10px; overflow: hidden; background: #051105; border: 1px solid #004400; border-radius: 4px; padding: 10px; }
        .mapping-list { flex: 1.5; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(5, 1fr); gap: 5px; overflow-y: auto; }
        .map-btn { background: #002200; border: 1px solid #004400; color: #008800; padding: 0 5px; border-radius: 3px; font-size: 12px; cursor: pointer; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .map-btn span { display: block; line-height: 1.1; font-weight: bold; }
        .map-btn.active-map { background: #004400; color: #0f0; border-color: #0f0; box-shadow: 0 0 10px rgba(0,255,0,0.5); text-shadow: 0 0 2px #0f0; }
        #matrix-off-btn.active-map { background: #002200 !important; color: #ff0000 !important; border-color: #ff0000 !important; box-shadow: 0 0 15px #ff0000 !important; animation: pulse 0.5s infinite alternate; }
        .map-set-display { font-family: 'Orbitron'; color: #0f0; font-size: 9px; margin-top: 2px; }
        .modifiers-container { flex: 1; display: flex; flex-direction: column; justify-content: space-evenly; border-top: 1px solid #004400; padding-top: 5px; }

        /* TEXT */
        .text-input-wrapper { background: #fff; padding: 5px; border-radius: 4px; border: 1px solid #000; display: flex; flex-direction: column; }
        #text-content { 
            width: 100%; border: none; outline: none; 
            font-family: 'Roboto Mono', monospace; font-size: 14px; font-weight: bold; 
            color: #000; background: transparent; 
            resize: none; 
            height: 65px; 
            line-height: 1.3;
            /* AJOUT : Centre le texte horizontalement dans la zone de saisie */
            text-align: center;
        }
        .text-toggle-btn { width: 100%; padding: 10px; margin-top:10px; border-radius: 6px; background: #002200; color: #008800; border: 2px solid #004400; font-weight: bold; font-family: 'Orbitron'; font-size: 14px; cursor: pointer; transition: 0.2s; }
        .text-toggle-btn.active { background: #004400; color: #0f0; border-color: #0f0; box-shadow: 0 0 10px rgba(0,255,0,0.5); }
        .dropdown { width: 100%; background: #002200; color: #0f0; border: 1px solid #004400; padding: 5px; font-family: 'Roboto Mono'; font-size: 11px; border-radius: 3px; margin-top: 2px; }
        
        /* FOOTER */
        .panel-footer { padding: 10px 15px; background: #051105; border-top: 1px solid #004400; display: flex; flex-direction: column; gap: 8px; flex-shrink: 0; }
        .footer-buttons { display: flex; gap: 8px; height: 36px; }
        .led-btn { flex: 1; border-radius: 4px; font-weight: 900; cursor: pointer; text-transform: uppercase; font-size: 11px; letter-spacing: 1px; display: flex; align-items: center; justify-content: center; font-family: 'Orbitron'; text-align: center; }
        .signature { text-align: center; font-size: 8px; color: #004400; margin-top: 2px; font-family: 'Orbitron'; opacity: 0.8; }
        
        /* HELP STYLES */
        .help-signature { font-family: 'Orbitron'; font-size: 12px; color: var(--lcd-on); text-align: center; margin-bottom: 15px; border-bottom: 1px solid #004400; padding-bottom: 10px; }
        .help-section { margin-bottom: 25px; border-bottom: 1px solid #003300; padding-bottom: 15px; }
        .help-title { color: #fff; font-family: 'Orbitron'; font-size: 12px; margin-bottom: 8px; font-weight: 900; letter-spacing: 1px; text-shadow: 0 0 5px #005500; }
        .help-text { font-size: 10px; color: #00aa00; line-height: 1.6; text-align: justify; font-family: 'Roboto Mono'; }
        .help-text strong { color: var(--lcd-on); }
        
        #help-content { margin-top: 50px; padding-top: 20px; border-top: 1px solid #003300; width: 100%; }

        /* MODALS */
        #modal-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); 
            display: none; justify-content: center; align-items: center; z-index: 3000; pointer-events: auto;
        }
        .modal-box { 
            background: #002200; border: 2px solid var(--lcd-on); padding: 20px; border-radius: 8px; 
            text-align: center; width: 80%; max-width: 300px; box-shadow: 0 0 20px var(--lcd-on);
        }
        .modal-title { font-family: 'Orbitron'; color: var(--lcd-on); margin-bottom: 15px; font-size: 14px; }
        .modal-input-row { display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; }
        .modal-input-grp { display: flex; flex-direction: column; }
        .modal-input-grp label { font-size: 9px; color: #00aa00; margin-bottom: 5px; }
        .modal-input-grp input { width: 60px; padding: 5px; background: #000; border: 1px solid #005500; color: #0f0; text-align: center; }
        .modal-btn { padding: 8px 20px; background: var(--lcd-on); border: none; font-weight: bold; cursor: pointer; border-radius: 4px; }

        /* QR CODE */
        #qr-modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 5000;
            display: none; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
        }
        .qr-box {
            background: #001100; border: 2px solid var(--lcd-on);
            padding: 20px; border-radius: 10px; width: 90%; max-width: 400px;
            display: flex; flex-direction: column; align-items: center; gap: 15px;
            box-shadow: 0 0 30px rgba(51, 255, 51, 0.2);
            animation: slideIn 0.3s ease-out;
        }
        .qr-title { font-family: 'Orbitron'; color: var(--lcd-on); font-size: 16px; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--lcd-on); }
        .code-textarea {
            width: 100%; height: 60px; background: #002200; border: 1px solid #005500;
            color: #0f0; font-family: 'Roboto Mono'; font-size: 10px; padding: 5px;
            border-radius: 4px; resize: none; word-break: break-all;
        }
        .qr-actions { display: flex; gap: 10px; width: 100%; }
        .qr-btn-close { background: transparent; border: 1px solid #ff3333; color: #ff3333; padding: 8px; flex: 1; cursor: pointer; font-family: 'Orbitron'; font-weight: bold; }
        .qr-btn-copy { background: var(--lcd-on); border: 1px solid #fff; color: #000; padding: 8px; flex: 1; cursor: pointer; font-family: 'Orbitron'; font-weight: bold; }
        .qr-btn-paste { background: #3388ff; border: 1px solid #fff; color: #fff; padding: 8px; flex: 1; cursor: pointer; font-family: 'Orbitron'; font-weight: bold; }
        @keyframes slideIn { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        /* ACTION BOXES */
        .help-container { display: flex; flex-direction: column; height: 100%; gap: 15px; padding-bottom: 5px; }
        .action-box {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: #001100; border-radius: 8px; border: 2px solid var(--lcd-on);
            box-shadow: 0 0 15px rgba(51, 255, 51, 0.1); width: 100%; cursor: pointer;
            text-decoration: none; transition: 0.2s; position: relative; padding: 15px 10px; overflow: hidden;
        }
        .action-box:hover { background: #002200; box-shadow: 0 0 30px rgba(51, 255, 51, 0.3); transform: scale(1.02); z-index: 10; }
        .action-box.flash { background: var(--lcd-on) !important; box-shadow: 0 0 60px var(--lcd-on) !important; border-color: #fff !important; }
        .action-box.flash span { color: #000 !important; text-shadow: none !important; }
        
        .box-title { 
            font-family: 'Orbitron'; font-weight: 900; font-size: 14px; color: #00ff00; 
            text-align: center; margin-bottom: 5px; pointer-events: none; 
            text-shadow: 0 0 5px #00ff00, 0 0 15px #00ff00, 0 0 30px #00ff00;
            width: 100%; line-height: 1.2; text-transform: uppercase;
        }
        .box-sub { 
            font-family: 'Orbitron'; font-weight: 900; font-size: 11px; color: #00ff00; 
            text-align: center; pointer-events: none; letter-spacing: 1px; line-height: 1.4; width: 100%;
            text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00; text-transform: uppercase;
        }

        /* ROSSIGNOL BRANDING */
        .rossignol-header { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 5px; width: 100%; }
        .rossignol-title {
            font-family: 'Orbitron'; font-weight: 900; font-size: 19px; color: #00ff00; 
            text-shadow: 0 0 5px #00ff00, 0 0 15px #00ff00, 0 0 30px #00ff00; 
            text-align: center; white-space: nowrap; line-height: 1.2;
        }
        .rossignol-icon { font-size: 20px; filter: drop-shadow(0 0 8px #00ff00); }
        .rossignol-neon-sub {
            font-family: 'Orbitron'; font-weight: 900; font-size: 13px; color: #00ff00; 
            text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00; display: block; 
            margin-top: 4px; letter-spacing: 1px; text-decoration: none; text-transform: uppercase; 
        }
        @media (max-width: 600px) {
            .rossignol-title { font-size: 14px; }
            .rossignol-neon-sub { font-size: 10px; }
            .rossignol-icon { font-size: 16px; }
            .manual-warning { font-size: 9px; }
        }

        .manual-warning {
            font-family: 'Orbitron'; font-weight: 900; font-size: 8px; color: #ff3333; 
            margin-top: 10px; text-align: center; max-width: 90%; line-height: 1.5; 
            text-shadow: 0 0 5px #500; text-transform: uppercase;
        }

        .dev-msg-active { 
            font-weight: 900 !important; font-size: 13px !important; color: #ff3333 !important; 
            line-height: 1.5 !important; animation: pulse 0.2s infinite; text-shadow: 0 0 5px #ff0000;
            width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;
        }
/* --- PATCH MOBILE ELASTIQUE (NO SCROLL) --- */
    @media (max-width: 768px) {
        /* 1. On interdit le scroll vertical dans les onglets */
        .panel-content {
            overflow-y: hidden !important;
            height: 100% !important;
            justify-content: space-between; /* R√©partit les √©l√©ments √©quitablement */
            padding-bottom: 5px !important;
        }

        /* 2. La roue devient totalement √©lastique */
        .wheel-wrapper {
            flex: 1 1 auto !important; /* Peut grandir et r√©tr√©cir */
            min-height: 0 !important; /* Autorise le r√©tr√©cissement extr√™me */
            padding: 5px 0 !important;
        }
        .wheel-container {
            /* La roue s'adapte √† la plus petite dimension dispo (largeur ou hauteur) */
            width: min(55vw, 30vh) !important;
            height: min(55vw, 30vh) !important;
            border-width: 8px !important; /* Bordure plus fine sur mobile */
        }

        /* 3. On tasse les groupes de contr√¥le */
        .control-group {
            flex-shrink: 1; /* Autorise les sliders √† se serrer */
            margin-bottom: 2px !important; /* R√©duit les marges */
            display: flex; 
            flex-direction: column;
            justify-content: center;
        }
        
        /* 4. Inputs et Sliders plus compacts */
        input[type=range] { height: 18px !important; margin: 0 !important; }
        .lcd-input { height: 18px !important; font-size: 9px !important; padding: 0 4px !important; }
        .label-row { margin-bottom: 1px !important; font-size: 8px !important; }
        .rgb-section { margin-top: 2px !important; }
        .hex-input { margin: 2px 0 !important; padding: 2px !important; height: 25px !important; }

        /* 5. Section M√©moire compacte en bas */
        .memory-section {
            margin-top: 0 !important;
            padding-top: 2px !important;
            flex-shrink: 0; /* On garde les m√©moires fixes pour ne pas les √©craser */
        }
        .memory-row { height: 35px !important; }
        
        /* Cache les √©l√©ments d√©coratifs inutiles si l'√©cran est vraiment petit */
        .memory-label { display: none !important; } 
    }

    </style>
</head>
<body>

    <div id="startup-overlay">
        <div class="intro-lang-bar" id="intro-lang-bar">
            <div class="intro-lang-btn active" onclick="setIntroLang('FR', event)">FR</div>
            <div class="intro-lang-btn" onclick="setIntroLang('EN', event)">EN</div>
        </div>

        <div class="startup-box">
            <div class="startup-title" id="intro-title">INTRODUCTION</div>
            <div class="startup-text" id="intro-text">
                Shnopia Light Engine est une interface web universelle con√ßue pour transformer instantan√©ment n'importe quel √©cran (ordinateur, tablette, smartphone) en dalle de lumi√®re professionnelle. Elle contr√¥le votre √©cran comme un projecteur de cin√©ma enti√®rement ajustable, sans aucune installation.
            </div>
            <div class="startup-hint" id="intro-hint">CLIQUEZ POUR CONTINUER</div>
        </div>
    </div>

    <canvas id="light-canvas"></canvas>
    <canvas id="text-canvas"></canvas>

    <div id="qr-modal-overlay" onclick="closeQrModal(event)">
        <div class="qr-box" onclick="event.stopPropagation()">
            <div class="qr-title">SHNOPIA CODE</div>
            <div style="width:100%; text-align:left; font-size:10px; color:#00aa00; margin-bottom:5px; font-family:'Orbitron';">
                CODE DE CONFIGURATION (COPIER/COLLER) :
            </div>
            <textarea id="code-text-area" class="code-textarea" onclick="this.select()"></textarea>
            <div class="qr-actions">
                <button class="qr-btn-copy" onclick="copyCodeToClip()">COPIER</button>
                <button class="qr-btn-paste" onclick="pasteCodeFromClip()">COLLER</button>
                <button class="qr-btn-close" onclick="closeQrModal(true)">FERMER</button>
            </div>
        </div>
    </div>

    <div id="modal-overlay" onclick="closeModalOnOutside(event)">
        <div class="modal-box">
            <div class="modal-title">CUSTOM MATRIX</div>
            <div class="modal-input-row">
                <div class="modal-input-grp">
                    <label>COLS</label>
                    <input type="number" id="custom-w" value="50" min="1">
                </div>
                <div class="modal-input-grp">
                    <label>ROWS</label>
                    <input type="number" id="custom-h" value="50" min="1">
                </div>
            </div>
            <button class="modal-btn" onclick="applyCustomMatrix()">APPLY</button>
        </div>
    </div>

    <div id="ui-layer" onclick="handleGlobalClick(event)">
        <div class="control-panel" id="main-panel" onclick="event.stopPropagation()">
            <div class="drag-bar" id="drag-handle"><div class="grip-lines"></div></div>
            <div class="panel-header">
                <span class="app-title">Shnopia Light Engine V8.5</span>
                
                <div class="header-controls">
                    <span class="lang-icon" onclick="toggleLangMenu(event)">üåç</span>
                    <div id="lang-menu">
                        <div class="lang-option" onclick="setLangGlobal('FR')">FRAN√áAIS</div>
                        <div class="lang-option" onclick="setLangGlobal('EN')">ENGLISH</div>
                    </div>

                    <div class="header-preview-box" onclick="togglePreviewFS()"><canvas id="preview-canvas"></canvas></div>
                    <button class="hide-btn" style="color:#f5a623; border-color:#f5a623;" onclick="handleShnopiaCode()">üíæ CODE</button>
                </div>
            </div>

            <div class="tabs">
                <button class="tab-btn" onclick="switchTab('tab-live', this)" data-tr="LIVE">LIVE</button>
                <button class="tab-btn active" onclick="switchTab('tab-wheel', this)" data-tr="COLOR">COLOR</button>
                <button class="tab-btn" onclick="switchTab('tab-cct', this)" data-tr="WHITE">WHITE</button>
                <button class="tab-btn" onclick="switchTab('tab-fx', this)" data-tr="FX_TITLE">FX</button>
                <button class="tab-btn" onclick="switchTab('tab-matrix', this)" data-tr="MATRIX">MATRIX</button>
                <button class="tab-btn" onclick="switchTab('tab-text', this)" data-tr="TEXT">TEXT</button>
                <button class="tab-btn" onclick="switchTab('tab-help', this)" data-tr="HELP">HOW TO USE</button>
            </div>

            <div id="tab-live" class="panel-content">
                <div style="display: flex; gap: 5px; margin-bottom: 10px; width: 100%;">
                    <button class="momentary-btn" style="flex: 4; padding:10px; border:1px dashed #004400;" onclick="autoRecordAll()">
                        üé• G√âN√âRER PREVIEWS
                    </button>
                    <button id="live-save-global-btn" class="momentary-btn" style="flex: 1; border-color: #f5a623; color: #f5a623;" onclick="toggleLiveSaveMode()">
                        SAVE
                    </button>
                </div> 
                <div class="live-grid" id="live-grid"></div>
            </div>

            <div id="tab-wheel" class="panel-content visible">
                <div class="wheel-wrapper"><div class="wheel-container" id="color-wheel"><div class="wheel-cursor" id="wheel-cursor"></div></div></div>
                <div class="control-group">
                    <div class="label-row"><span data-tr="SATURATION">SATURATION</span><input type="number" class="lcd-input" id="val-sat-input" value="100" min="0" max="100"></div>
                    <input type="range" min="0" max="100" value="100" id="input-sat">
                </div>
                <input type="text" class="hex-input" id="hex-input" value="#FF0000" maxlength="7">
                
                <div class="rgb-section">
                    <div class="control-group">
                        <div class="label-row color-r"><span data-tr="RED">RED</span><input type="number" class="lcd-input color-r" id="val-r-input" value="255" min="0" max="255"></div>
                        <input type="range" id="input-r" min="0" max="255" value="255">
                    </div>
                    <div class="control-group">
                        <div class="label-row color-g"><span data-tr="GREEN">GREEN</span><input type="number" class="lcd-input color-g" id="val-g-input" value="0" min="0" max="255"></div>
                        <input type="range" id="input-g" min="0" max="255" value="0">
                    </div>
                    <div class="control-group">
                        <div class="label-row color-b"><span data-tr="BLUE">BLUE</span><input type="number" class="lcd-input color-b" id="val-b-input" value="0" min="0" max="255"></div>
                        <input type="range" id="input-b" min="0" max="255" value="0">
                    </div>
                </div>

                <button class="recall-btn momentary-btn" onclick="recallWhite()" data-tr="RECALL_WHITE">RECALL WHITE SETTINGS</button>
                <button class="activate-btn momentary-btn" onclick="activateStatic('WHEEL')" data-tr="ACTIVATE_COLOR">ACTIVER LA COULEUR</button>
                
                <div class="memory-section">
                    <div class="memory-label" data-tr="MEMORIES">M√©moriser une couleur : SAVE puis bouton</div>
                    <div class="memory-row" id="color-memories"></div>
                </div>
            </div>

            <div id="tab-cct" class="panel-content">
                <div class="control-group">
                    <div class="label-row" style="align-items: center;">
    <span data-tr="KELVIN" style="font-size: 11px;">TEMPERATURE (KELVIN)</span>
    <span id="val-kelvin" class="lcd-input" style="font-size: 12px; width: 60px; text-align: center; display: inline-block;">3200K</span>
</div>
                    <input type="range" min="1750" max="10000" value="3200" id="input-kelvin">
                    <div class="presets-row">
                        <button class="preset-btn k2700" onclick="setKelvin(2700, this)">2700K</button>
                        <button class="preset-btn k3200 active" onclick="setKelvin(3200, this)">3200K</button>
                        <button class="preset-btn k4300" onclick="setKelvin(4300, this)">4300K</button>
                        <button class="preset-btn k5600" onclick="setKelvin(5600, this)">5600K</button>
                        <button class="preset-btn k6500" onclick="setKelvin(6500, this)">6500K</button>
                    </div>
                </div>
                <div class="control-group" style="margin-top:15px;">
                    <div class="label-row"><span data-tr="TINT">TINT (G/M)</span><span id="val-tint">0</span></div>
                    <input type="range" min="-50" max="50" value="0" id="input-tint">
                </div>
                <div class="label-row" style="margin-top:15px;"><span data-tr="MANUAL_WHITE">MANUEL BLANC</span></div>
                <input type="text" class="hex-input" id="hex-input-white" value="#FFFFFF" maxlength="7">
                
                <div class="rgb-section">
                    <div class="control-group">
                        <div class="label-row color-r"><span data-tr="RED">RED</span><input type="number" class="lcd-input color-r" id="val-white-r-input" value="255" min="0" max="255"></div>
                        <input type="range" id="input-white-r" min="0" max="255" value="255">
                    </div>
                    <div class="control-group">
                        <div class="label-row color-g"><span data-tr="GREEN">GREEN</span><input type="number" class="lcd-input color-g" id="val-white-g-input" value="255" min="0" max="255"></div>
                        <input type="range" id="input-white-g" min="0" max="255" value="255">
                    </div>
                    <div class="control-group">
                        <div class="label-row color-b"><span data-tr="BLUE">BLUE</span><input type="number" class="lcd-input color-b" id="val-white-b-input" value="255" min="0" max="255"></div>
                        <input type="range" id="input-white-b" min="0" max="255" value="255">
                    </div>
                </div>
                
                <button class="activate-btn momentary-btn" onclick="activateStatic('CCT')" data-tr="ACTIVATE_WHITE">ACTIVER LE BLANC</button>
                
                <div class="memory-section">
                    <div class="memory-label" data-tr="MEMORIES">M√©moriser une couleur: SAVE puis case </div>
                    <div class="memory-row" id="white-memories"></div>
                </div>
            </div>

            <div id="tab-fx" class="panel-content">
                <div class="control-group">
                    <div class="label-row"><span data-tr="SPEED">SPEED</span><input type="number" class="lcd-input" id="val-speed-input" value="4" min="1" max="100"></div>
                    <input type="range" min="1" max="100" value="4" id="input-speed">
                </div>
                <div class="label-row" style="margin-top:2px;"><span data-tr="COLOR_OVERRIDE">COLOR OVERRIDE (CLICK TO REPLACE FX COLORS)</span></div>
                
                <div class="palette-container" id="palette-fx"></div>
                <div class="fx-grid" id="master-fx-grid" style="margin-top:5px;"></div>
                
                <div class="modifiers-container" style="margin-top:10px; border-top:1px solid #004400; padding-top:10px; flex-shrink: 0;">
                    <div class="control-group">
                        <div class="label-row"><span>PARAM A (STRUCT)</span><span id="val-fx-p1">50%</span></div>
                        <input type="range" min="0" max="100" value="50" id="input-fx-p1" oninput="updateFxParam(1, this.value)">
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>PARAM B (COLOR/VAR)</span><span id="val-fx-p2">50%</span></div>
                        <input type="range" min="0" max="100" value="50" id="input-fx-p2" oninput="updateFxParam(2, this.value)">
                    </div>
                    <div class="control-group">
                        <div class="label-row"><span>PARAM C (DYN/SEUIL)</span><span id="val-fx-p3">50%</span></div>
                        <input type="range" min="0" max="100" value="50" id="input-fx-p3" oninput="updateFxParam(3, this.value)">
                    </div>
                </div>

                <div style="margin-top: 10px; border-top: 1px solid #004400; padding-top: 8px;">
                    <div class="label-row" style="margin-bottom: 5px;">FX MEMORY</div>
                    <div style="display: flex; gap: 5px; height: 40px;">
                        <button class="momentary-btn" style="flex:1; border: 1px solid #ff3333; color: #ff3333;" onclick="resetFxSettings()">RESET</button>
                        <button id="fx-mem-0" class="momentary-btn" style="flex:1;" onclick="handleFxMemClick(0)">MEM 1</button>
                        <button id="fx-mem-1" class="momentary-btn" style="flex:1;" onclick="handleFxMemClick(1)">MEM 2</button>
                        <button id="fx-mem-2" class="momentary-btn" style="flex:1;" onclick="handleFxMemClick(2)">MEM 3</button>
                        <button id="fx-save-btn" class="momentary-btn" style="flex:0.6; font-size:9px; border-color:#f5a623; color:#f5a623;" onclick="toggleFxSaveMode()">SAVE</button>
                    </div>
                </div>
            </div>
<div id="tab-matrix" class="panel-content">
                <div class="matrix-section" style="height:auto; flex:1;">
                    <div class="label-row" data-tr="PRESETS">PRESETS</div>
                    <div class="mapping-list" id="matrix-pad-grid" style="grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(4, 1fr); gap: 5px;"></div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="matrix-container" onclick="toggleMatrixDimension()" style="flex: 1; background: #001100; border: 2px solid #005500; border-radius: 6px; padding: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; height: 55px; box-shadow: inset 0 0 15px rgba(0,0,0,0.8); transition: 0.2s;">
                            <span style="font-family: 'Orbitron'; font-size: 8px; color: #00aa00; letter-spacing: 2px; margin-bottom: 2px; opacity: 0.8;">MATRICE</span>
                            <span id="matrix-display" style="font-family: 'Orbitron'; font-size: 18px; color: var(--lcd-on); font-weight: 900; text-shadow: 0 0 8px rgba(51, 255, 51, 0.4);">N/A</span>
                        </button>
                        <div id="cells-container" style="flex: 1; background: #001100; border: 2px solid #005500; border-radius: 6px; padding: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 55px; box-shadow: inset 0 0 15px rgba(0,0,0,0.8); transition: 0.2s;">
                            <span style="font-family: 'Orbitron'; font-size: 8px; color: #00aa00; letter-spacing: 2px; margin-bottom: 2px; opacity: 0.8;">CELLS</span>
                            <span id="cells-display" style="font-family: 'Orbitron'; font-size: 18px; color: var(--lcd-on); font-weight: 900; text-shadow: 0 0 8px rgba(51, 255, 51, 0.4);">N/A</span>
                        </div>
                    </div>

                    <div class="label-row" style="margin-top:15px;" data-tr="MODIFIERS">MODIFIERS</div>
                    <div class="modifiers-container">
                        <div class="control-group modifier-slider" id="grp-grid">
                            <div class="label-row"><span>MULTIPLIER</span><span id="val-grid-lvl">x1</span></div>
                            <input type="range" min="-5" max="10" value="0" id="input-grid-lvl">
                        </div>
                        <div class="control-group modifier-slider" id="grp-warp">
                            <div class="label-row"><span>WARP</span><span id="val-warp-lvl">0</span></div>
                            <input type="range" min="0" max="10" value="0" id="input-warp-lvl" oninput="updateWarpSlider(this)">
                        </div>
                        <div class="control-group modifier-slider" id="grp-noise">
                            <div class="label-row"><span>NOISE</span><span id="val-noise-lvl">0</span></div>
                            <input type="range" min="0" max="10" value="0" id="input-noise-lvl" oninput="updateNoiseSlider(this)">
                        </div>
                    </div>

                    <div style="margin-top: 10px; border-top: 1px solid #004400; padding-top: 8px;">
                        <div class="label-row" style="margin-bottom: 5px;">MODIFIERS MEMORY</div>
                        <div style="display: flex; gap: 5px; height: 40px;">
                            <button class="momentary-btn" style="flex:1; border: 1px solid #ff3333; color: #ff3333;" onclick="resetModifiers()">RESET</button>
                            <button id="mod-mem-0" class="momentary-btn" style="flex:1;" onclick="handleModMemClick(0)">MEM 1</button>
                            <button id="mod-mem-1" class="momentary-btn" style="flex:1;" onclick="handleModMemClick(1)">MEM 2</button>
                            <button id="mod-mem-2" class="momentary-btn" style="flex:1;" onclick="handleModMemClick(2)">MEM 3</button>
                            <button id="mod-save-btn" class="momentary-btn" style="flex:0.6; font-size:9px; border-color:#f5a623; color:#f5a623;" onclick="toggleModSaveMode()">SAVE</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="tab-text" class="panel-content">
                <div class="control-group">
                    <div class="label-row"><span data-tr="MESSAGE">MESSAGE</span></div>
                    <div class="text-input-wrapper">
                       <textarea id="text-content" placeholder="TAPEZ ICI" rows="3">Rossignol Grip Vibe Coding</textarea>
                    </div>
                </div>
                
                <button class="text-toggle-btn momentary-btn" id="btn-text-toggle" onclick="toggleText()" data-tr="TEXT_OFF">TEXTE: OFF</button>
                
                <div style="margin-top: 10px;">
                    <div class="control-group">
                        <div class="label-row"><span data-tr="FONT">POLICE</span></div>
                       <select id="input-text-font" class="dropdown">
                            <option value="'Black Ops One', cursive" selected>Militaire</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <div class="label-row"><span data-tr="EFFECT">EFFET</span></div>
                        <select id="input-text-effect" class="dropdown">
                            <option value="NONE">Aucun</option>
                            <option value="NEON">Neon</option>
                            <option value="GLITCH">Glitch</option>
                            <option value="WAVE">Wave</option>
                            <option value="TYPE">Typewriter</option>
                            <option value="STROKE" selected>Outline</option>
                            <option value="MIRROR">Reflet</option>
                            <option value="SHAKE">Tremblement</option>
                            <option value="RAINBOW">Rainbow</option>
                            <option value="BOUNCE">Rebond</option>
                            <option value="BREATHE">Respiration</option>
                        </select>
                    </div>
                    
                    <div class="control-group modifier-slider" id="grp-text-fx">
                        <div class="label-row"><span data-tr="INTENSITY">INTENSIT√â</span><span id="val-text-fx-lvl">50%</span></div>
                        <input type="range" min="0" max="100" value="50" id="input-text-fx-lvl" oninput="updateTextSlider()">
                    </div>
                    
                    <div class="control-group">
                        <div class="label-row"><span data-tr="SIZE">TAILLE</span><span id="val-text-size">22%</span></div>
                        <input type="range" min="5" max="100" value="22" id="input-text-size">
                    </div>
                    
                    <div class="control-group">
                        <div class="label-row"><span data-tr="SPEED">VITESSE</span><span id="val-text-speed">1</span></div>
                        <input type="range" min="0" max="30" value="1" id="input-text-speed">
                    </div>
                    
                    <div class="control-group">
                        <div class="label-row"><span data-tr="COLOR">COULEUR</span></div>
                        <input type="color" id="input-text-color" value="#ffffff" style="width:100%; height:30px; border:none; padding: 0;">
                    </div>

                    <div class="memory-section" style="margin-top: 15px; border-top: 1px solid #004400; padding-top: 10px;">
                        <div class="memory-row" id="text-memories"></div>
                    </div>
                </div>
            </div>
            
            <div id="tab-help" class="panel-content">
                <div class="help-container">
                    <div class="action-box" onclick="triggerAction(this, 'mail')">
                        <div class="rossignol-header">
                            <span class="rossignol-icon">üé¨</span>
                            <span class="rossignol-title">Rossignol Grip Vibe Coding</span>
                            <span class="rossignol-icon">üé•</span>
                        </div>
                        <span class="rossignol-neon-sub">üá´üá∑ <span data-tr="CONTACT_SUB">CONTACT & SUPPORT:</span></span>
                        <span class="rossignol-neon-sub">ROSSIGNOL.P@GMAIL.COM</span>
                    </div>

                    <div class="action-box" onclick="triggerDevMsg(this)">
                        <span class="box-title" id="dev-title" data-tr="DEV_TITLE">MESSAGE DU D√âVELOPPEUR</span>
                        <span class="box-sub" id="dev-sub" data-tr="DEV_SUB">CLIQUEZ POUR LIRE</span>
                    </div>

                    <div class="action-box" onclick="triggerAction(this, 'manual')">
                        <span class="box-title" data-tr="MANUAL_TITLE">MANUEL UTILISATEUR</span>
                        <div class="manual-warning" data-tr="MANUAL_WARN">
                            Attention vous allez sortir de l'application, il faudra revenir au bon onglet dans votre navigateur pour retrouver vos Set-up
                        </div>
                    </div>

                    <a href="https://lightmyscreen.com/SLE V8 Final.html" download id="download-link" class="action-box" onclick="triggerDownload(this);">
                        <span class="box-title" data-tr="DL_TITLE">T√âL√âCHARGER L'APP</span>
                        <span class="box-sub">VERSION OFFLINE</span>
                    </a>
                </div>
            </div>

            <div class="panel-footer">
                <div><div class="label-row"><span data-tr="DIMMER">INTENSIT√â</span><input type="number" class="lcd-input" id="val-dimmer-input" value="100" min="0" max="100"></div><input type="range" min="0" max="100" value="100" id="input-dimmer"></div>
                <div class="footer-buttons">
                    <button class="led-btn blackout-btn" id="btn-blackout" onclick="toggleBlackout()">BLACKOUT</button>
                    <button class="led-btn fullscreen-btn momentary-btn" onclick="toggleFS()" data-tr="FULLSCREEN">FULL SCREEN</button>
                </div>
                <div class="signature">
                    D√©velopp√© par Shnopia par amour du cin√©ma
                    <div style="margin-top: 4px; font-size: 9px; color: #005500; border-top: 1px solid #002200; padding-top: 2px;">
                        SYSTEM ACCESS: <span id="global-counter" style="color: var(--lcd-on); font-weight: bold; letter-spacing: 1px; text-shadow: 0 0 5px rgba(51, 255, 51, 0.5);">CONNECTING...</span>
                    </div>
                </div>
            </div>
    </div>

    <script>
       // --- INTEGRATION FONTS.JS ---
       const CUSTOM_FONTS = [
            "https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap",
            "https://fonts.googleapis.com/css2?family=Orbitron:wght@500;900&display=swap",
            "https://fonts.googleapis.com/css2?family=Anton&family=Bebas+Neue&family=Press+Start+2P&family=Lobster&family=Pacifico&family=Bangers&family=Creepster&family=Monoton&family=Audiowide&family=Syncopate&family=VT323&family=Righteous&family=Fredoka+One&family=Luckiest+Guy&family=Russo+One&family=Special+Elite&family=Wallpoet&display=swap"
       ];

       const FONT_OPTIONS = [
            { value: "'Roboto Mono', monospace", label: "Standard Tech" },
            { value: "'Bebas Neue', sans-serif", label: "Cin√©ma" },
            { value: "'Press Start 2P', cursive", label: "Pixel" },
            { value: "'Lobster', cursive", label: "Manuscrit" },
            { value: "'Orbitron', sans-serif", label: "Futuriste" },
            { value: "'Pacifico', cursive", label: "Vintage" },
            { value: "'Bangers', cursive", label: "Comics" },
            { value: "'Creepster', cursive", label: "Horreur" },
            { value: "'Monoton', cursive", label: "R√©tro Lines" },
            { value: "'Black Ops One', cursive", label: "Militaire", selected: true }
       ];

       // --- INTEGRATION LANGUES (FR / EN ONLY) ---
       const DICT = {
           FR: {
               INTRO_TITLE: "INTRODUCTION",
               INTRO_TEXT: "Shnopia Light Engine est une interface web universelle con√ßue pour transformer instantan√©ment n'importe quel √©cran (ordinateur, tablette, smartphone) en dalle de lumi√®re professionnelle. Elle contr√¥le votre √©cran comme un projecteur de cin√©ma enti√®rement ajustable, sans aucune installation.",
               INTRO_HINT: "CLIQUEZ POUR CONTINUER",
               LIVE: "LIVE", COLOR: "COULEUR", WHITE: "BLANC", FX_TITLE: "FX", MATRIX: "MATRICE", TEXT: "TEXTE", HELP: "AIDE",
               SATURATION: "SATURATION", RED: "ROUGE", GREEN: "VERT", BLUE: "BLEU",
               RECALL_WHITE: "RAPPEL REGLAGES BLANC", ACTIVATE_COLOR: "ACTIVER LA COULEUR", MEMORIES: "M√©moriser une couleur: SAVE puis case",
               KELVIN: "TEMPERATURE (KELVIN)", TINT: "TEINTE (G/M)", MANUAL_WHITE: "MANUEL BLANC", ACTIVATE_WHITE: "ACTIVER LE BLANC",
               SPEED: "VITESSE", COLOR_OVERRIDE: "FORCER COULEUR (CLIQUEZ POUR REMPLACER)",
               PRESETS: "PRESETS", MODIFIERS: "MODIFIERS",
               MESSAGE: "MESSAGE", TEXT_OFF: "TEXTE: OFF", TEXT_ON: "TEXTE: ON",
               FONT: "POLICE", EFFECT: "EFFET", INTENSITY: "INTENSIT√â", SIZE: "TAILLE",
               CONTACT_SUB: "CONTACT & SUPPORT:",
               DEV_TITLE: "MESSAGE DU D√âVELOPPEUR", DEV_SUB: "CLIQUEZ POUR LIRE",
               MANUAL_TITLE: "MANUEL UTILISATEUR", MANUAL_WARN: "Attention vous allez sortir de l'application, il faudra revenir au bon onglet dans votre navigateur pour retrouver vos Set-up",
               DL_TITLE: "T√âL√âCHARGER L'APP",
               DIMMER: "INTENSIT√â GLOBALE", FULLSCREEN: "PLEIN √âCRAN"
           },
           EN: {
               INTRO_TITLE: "INTRODUCTION",
               INTRO_TEXT: "Shnopia Light Engine is a universal web interface designed to instantly transform any screen (computer, tablet, smartphone) into a professional light panel. It controls your screen like a fully adjustable cinema projector, with zero installation.",
               INTRO_HINT: "CLICK TO CONTINUE",
               LIVE: "LIVE", COLOR: "COLOR", WHITE: "WHITE", FX_TITLE: "FX", MATRIX: "MATRIX", TEXT: "TEXT", HELP: "HELP",
               SATURATION: "SATURATION", RED: "RED", GREEN: "GREEN", BLUE: "BLUE",
               RECALL_WHITE: "RECALL WHITE SETTINGS", ACTIVATE_COLOR: "ACTIVATE COLOR", MEMORIES: "MEMORIES (TOP: LOAD / BOT: SAVE)",
               KELVIN: "TEMPERATURE (KELVIN)", TINT: "TINT (G/M)", MANUAL_WHITE: "MANUAL WHITE", ACTIVATE_WHITE: "ACTIVATE WHITE",
               SPEED: "SPEED", COLOR_OVERRIDE: "COLOR OVERRIDE (CLICK TO REPLACE)",
               PRESETS: "PRESETS", MODIFIERS: "MODIFIERS",
               MESSAGE: "MESSAGE", TEXT_OFF: "TEXT: OFF", TEXT_ON: "TEXT: ON",
               FONT: "FONT", EFFECT: "EFFECT", INTENSITY: "INTENSITY", SIZE: "SIZE",
               CONTACT_SUB: "CONTACT & SUPPORT:",
               DEV_TITLE: "DEVELOPER MESSAGE", DEV_SUB: "CLICK TO READ",
               MANUAL_TITLE: "USER MANUAL", MANUAL_WARN: "Warning: you are about to leave the app. You will need to return to the correct browser tab to restore your setup.",
               DL_TITLE: "DOWNLOAD APP",
               DIMMER: "GLOBAL DIMMER", FULLSCREEN: "FULL SCREEN"
           }
       };
       
       (function() {
            // Initialisation des polices
            CUSTOM_FONTS.forEach(url => {
                const link = document.createElement('link'); link.href = url; link.rel = 'stylesheet'; document.head.appendChild(link);
            });
            const select = document.getElementById('input-text-font'); select.innerHTML = ''; 
            FONT_OPTIONS.forEach(font => {
                const option = document.createElement('option'); option.value = font.value; option.innerText = font.label;
                if(font.selected) option.selected = true; select.appendChild(option);
            });
       })();
    
        // STARTUP
        let currentIntroLang = 'FR';
        const overlay = document.getElementById('startup-overlay');
        const langBtns = document.querySelectorAll('.intro-lang-btn');

        function setIntroLang(lang, event) {
            if(event) event.stopPropagation(); 
            currentIntroLang = lang;
            langBtns.forEach(b => b.classList.remove('active'));
            if(event) event.target.classList.add('active');
            const d = DICT[lang];
            if(d.INTRO_TITLE) document.getElementById('intro-title').innerText = d.INTRO_TITLE;
            if(d.INTRO_TEXT) document.getElementById('intro-text').innerText = d.INTRO_TEXT;
            if(d.INTRO_HINT) document.getElementById('intro-hint').innerText = d.INTRO_HINT;
        }

        // --- SHNOPIA WAKE LOCK (ANTI-DODO) ---
        let wakeLock = null;
        async function activateWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('üîí SHNOPIA WAKE LOCK : ACTIV√â (Pas de dodo !)');
                } catch (err) {
                    console.error(`Oups, le Wake Lock a √©chou√©: ${err.name}, ${err.message}`);
                }
            }
        }
        // Si on change d'onglet et qu'on revient, on r√©active le verrou !
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await activateWakeLock();
            }
        });

        overlay.addEventListener('click', () => {
            activateWakeLock(); // <--- ON LANCE LE CAF√â ICI !
            setLangGlobal(currentIntroLang);
            switchTab('tab-wheel', document.querySelector('.tab-btn:nth-child(2)')); 
            overlay.style.opacity = '0';
            setTimeout(() => { overlay.style.display = 'none'; }, 500);
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => { console.log("FS Blocked"); });
            }
            const fsBtn = document.querySelector('.fullscreen-btn');
            fsBtn.classList.add('blink-trigger');
            setTimeout(() => { fsBtn.classList.remove('blink-trigger'); }, 1200);
        });

        // UTILS
        function hexToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : {r:0,g:0,b:0}; }
        function rgbToHex(r,g,b) { return "#" + ((1<<24)+(Math.round(r)<<16)+(Math.round(g)<<8)+Math.round(b)).toString(16).slice(1).toUpperCase(); }
        function hslToRgb(h,s,l){ l/=100; s/=100; let k=n=>(n+h/30)%12, a=s*Math.min(l,1-l), f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1))); return [f(0)*255,f(8)*255,f(4)*255]; }
        function rgbToHsv(r, g, b) { r/=255, g/=255, b/=255; var max=Math.max(r, g, b), min=Math.min(r, g, b); var h, s, v=max; var d=max-min; s=max==0?0:d/max; if(max==min){h=0;}else{switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;} return { h: h * 360, s: s * 100, v: v * 100 }; }
        function hsvToRgb(h, s, v) { var r, g, b; var i; var f, p, q, t; h=Math.max(0,Math.min(360,h)); s=Math.max(0,Math.min(100,s)); v=Math.max(0,Math.min(100,v)); s/=100; v/=100; if(s==0){r=g=b=v;return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];} h/=60; i=Math.floor(h); f=h-i; p=v*(1-s); q=v*(1-s*f); t=v*(1-s*(1-f)); switch(i){case 0:r=v;g=t;b=p;break;case 1:r=q;g=v;b=p;break;case 2:r=p;g=v;b=t;break;case 3:r=p;g=q;b=v;break;case 4:r=t;g=p;b=v;break;default:r=v;g=p;b=q;} return [Math.round(r*255), Math.round(g*255), Math.round(b*255)]; }
        function kelvinToRgb(k){ let t=k/100,r,g,b; if(t<=66){r=255;g=99.47*Math.log(t)-161.1;if(t<=19)b=0;else b=138.5*Math.log(t-10)-305;}else{r=329.7*Math.pow(t-60,-0.133);g=288.1*Math.pow(t-60,-0.075);b=255;} return{r:c(r),g:c(g),b:c(b)}; }
        function applyTint(rgb,t){ return {r:c(rgb.r-t*0.5), g:c(rgb.g+t*1.5), b:c(rgb.b-t*0.5)}; }
function c(v){ return Math.max(0,Math.min(255,v)); }

// --- SHNOPIA NOISE ENGINE ---
// Un bruit simple et rapide pour simuler des textures organiques
const noise = (x, y) => {
    let ix = Math.floor(x), iy = Math.floor(y);
    let fx = x - ix, fy = y - iy;
    let ux = fx * fx * (3.0 - 2.0 * fx); // Smoothstep
    let uy = fy * fy * (3.0 - 2.0 * fy);
    const hash = (i, j) => {
        let n = Math.sin(i * 12.9898 + j * 78.233) * 43758.5453;
        return n - Math.floor(n);
    };
    let a = hash(ix, iy), b = hash(ix + 1, iy);
    let c = hash(ix, iy + 1), d = hash(ix + 1, iy + 1);
    return (a * (1 - ux) + b * ux) * (1 - uy) + (c * (1 - ux) + d * ux) * uy;
};

        const canvas = document.getElementById('light-canvas'); const ctx = canvas.getContext('2d');
        const textCanvas = document.getElementById('text-canvas'); const textCtx = textCanvas.getContext('2d');
        const previewCanvas = document.getElementById('preview-canvas'); const previewCtx = previewCanvas.getContext('2d');
        
        let CURRENT_LANG = 'FR';
        let state = {
            mode: 'WHEEL', kelvin: 3200, tint: 0, hue: 0, sat: 100, val: 100,
            dimmer: 100, blackout: false, fxMode: 0, 
            speed: 4, fxParam1: 50, fxParam2: 50, fxParam3: 50, mapMode: -1, time: 0, textTime: 0, 
            textOn: false, textString: "Rossignol Grip Vibe Coding", 
            textSize: 22, textSpeed: 1, textColor: "#ffffff", textPos: 0, 
            textFont: "'Black Ops One', cursive", textEffect: "STROKE", textFxLvl: 50, 
            gridActive: true, gridLevel: 1, warpActive: false, warpLevel: 0, noiseActive: false, noiseLevel: 0,
            whiteRgb: {r:255, g:255, b:255}, savedColors: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#00FFFF'], paletteActive: [false, false, false, false, false],
        };

        const MAPS = [
            {w: 8, h: 8, name: "1:1"}, {w: 12, h: 9, name: "4:3"}, {w: 16, h: 9, name: "16:9"},
            {w: 21, h: 9, name: "21:9"}, {w: 1, h: 1, name: "1 Zone"}, {w: 4, h: 2, name: "8 Zones"},
            {w: 4, h: 4, name: "16 Zones"}, {w: 6, h: 4, name: "24 Zones"}, {w: 16, h: 1, name: "Titan (H)"},
            {w: 50, h: 50, name: "SET"},
        ];
        
        const CINEMA_FX = [ "STATIC", "POLICE", "FIRE", "PAPARAZZI", "TV", "WELDING", "PROCESS", "BAD BULB", "STORM", "CANDLE", "STROBE", "EXPLOSION", "CLUB", "EMERGENCY", "ELEVATOR", "HORROR" ];
        const SHNOPIA_FX = [ "AURORA", "MATRIX", "CYBER", "PLASMA", "DISCO", "BIFROST", "SCANNER", "RIPPLE", "SNOW", "GLITCH", "BINARY", "HEARTBEAT", "WARP", "RAIN", "VORTEX", "KALEIDO" ];

        function addFxToMasterGrid(names, offset) {
            const container = document.getElementById('master-fx-grid');
            names.forEach((name, i) => {
                const id = offset + i;
                const div = document.createElement('div'); div.className = 'fx-card'; 
                if(id === 0) { div.classList.add('active'); div.id='fx-static'; }
                div.innerHTML = `<span>${name}</span>`; div.onclick = () => setEffect(id, div);
                container.appendChild(div);
            });
        }

        let isColorSaveMode = false;

        function updateMemoriesUI() {
            // Ajout de 'text-memories' √† la liste
            ['color-memories', 'white-memories', 'text-memories'].forEach(id => {
                const container = document.getElementById(id);
                if(!container) return;
                container.innerHTML = '';
                
                // 1. Les 5 slots de couleur
                state.savedColors.forEach((col, i) => {
                    const slot = document.createElement('div'); slot.className = 'memory-slot';
                    
                    const display = document.createElement('div'); 
                    display.className = 'memory-display-box'; 
                    display.style.backgroundColor = col; 
                    // Le clic g√®re maintenant SAVE ou LOAD selon le mode
                    display.onclick = () => handleColorMemClick(i); 
                    
                    slot.appendChild(display); 
                    container.appendChild(slot);
                });

                // 2. Le 6√®me bouton : SAVE GLOBAL
                const saveSlot = document.createElement('div'); 
                saveSlot.className = 'memory-slot';
                saveSlot.style.flex = '0.7'; // Un peu plus petit que les cases couleurs
                saveSlot.style.marginLeft = '4px';

                const saveBtn = document.createElement('button'); 
                saveBtn.className = 'global-save-btn'; 
                saveBtn.innerText = "SAVE"; 
                saveBtn.onclick = () => toggleColorSaveMode(); 

                if(isColorSaveMode) {
                    saveBtn.classList.add('saving-red');
                    saveBtn.innerText = "REC";
                }

                saveSlot.appendChild(saveBtn);
                container.appendChild(saveSlot);
            });
            updatePaletteUI();
        }

        function toggleColorSaveMode() {
            isColorSaveMode = !isColorSaveMode;
            updateMemoriesUI(); // Rafraichit pour afficher/masquer le rouge
        }

        function genPalette(targetId) {
            const container = document.getElementById(targetId); container.innerHTML = '';
            state.savedColors.forEach((col, i) => {
                const item = document.createElement('div'); item.className = 'palette-item';
                item.onclick = () => { state.paletteActive[i] = !state.paletteActive[i]; updatePaletteUI(); };
                const toggle = document.createElement('div'); toggle.className = 'palette-toggle'; 
                const display = document.createElement('div'); display.className = 'palette-display'; display.style.backgroundColor = col;
                item.appendChild(toggle); item.appendChild(display); container.appendChild(item);
            });
        }
        genPalette('palette-fx'); 

        function updatePaletteUI() {
            const id = 'palette-fx';
            const toggles = document.getElementById(id).getElementsByClassName('palette-toggle');
            const displays = document.getElementById(id).getElementsByClassName('palette-display');
            state.savedColors.forEach((col, i) => { 
                if(toggles[i]) { 
                    if(state.paletteActive[i]) toggles[i].classList.add('active'); else toggles[i].classList.remove('active'); 
                    displays[i].style.backgroundColor = col; 
                } 
            });
        }

        function toggleLangMenu(e) { e.stopPropagation(); document.getElementById('lang-menu').classList.toggle('show'); }
        
        function setLangGlobal(lang) {
            CURRENT_LANG = lang;
            document.getElementById('lang-menu').classList.remove('show');
            const d = DICT[lang];
            if (d && !d.FX_TITLE) d.FX_TITLE = "FX";
            if(d) {
                document.querySelectorAll('[data-tr]').forEach(el => {
                    const key = el.getAttribute('data-tr'); if(d[key]) el.innerText = d[key];
                });
            }
            const txtBtn = document.getElementById('btn-text-toggle');
            if(state.textOn) txtBtn.innerText = d.TEXT_ON; else txtBtn.innerText = d.TEXT_OFF;
        }
        
        // LIVE PAD SYSTEM
        const LIVE_SLOTS = 16;
        let liveMemory = new Array(LIVE_SLOTS).fill(null);
        let isRecording = false;
        let isLiveSaveMode = false;
        let selectedPadIndex = -1; 

        function initLiveGrid() {
            if (typeof SHNOPIA_DEFAULTS !== 'undefined' && Array.isArray(SHNOPIA_DEFAULTS)) {
                SHNOPIA_DEFAULTS.forEach((code, i) => {
                    if (i < LIVE_SLOTS) {
                        const decoded = decodeShnopiaCode(code);
                        if (decoded) {
                            let base = JSON.parse(JSON.stringify(state));
                            liveMemory[i] = Object.assign(base, decoded);
                        }
                    }
                });
            }
            const grid = document.getElementById('live-grid'); grid.innerHTML = '';
            for(let i=0; i<LIVE_SLOTS; i++) {
                const slot = document.createElement('div'); slot.className = 'live-slot';
                const pad = document.createElement('div'); pad.className = 'live-pad'; pad.id = `live-pad-${i}`; 
                pad.onclick = () => handleLivePadClick(i);
                updatePadVisual(pad, liveMemory[i], i);
                slot.appendChild(pad); grid.appendChild(slot);
            }
        }
        
        function updatePadVisual(el, mem, idx) {
            el.innerHTML = '';
            if(!mem) {
                el.style.backgroundColor = '#001100'; el.style.border = '1px solid #004400'; el.style.boxShadow = 'inset 0 0 10px rgba(0,0,0,0.8)';
                el.innerHTML = `<span class="empty-pad-text">EMPTY ${idx+1}</span>`; return;
            }
            if(mem.mode === 'WHEEL') {
                const rgb = hsvToRgb(mem.hue, mem.sat, mem.val); const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
                el.style.backgroundColor = hex; el.style.boxShadow = `0 0 10px ${hex}`;
            } else if(mem.mode === 'CCT') {
                const rgb = mem.whiteRgb; const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                el.style.backgroundColor = hex; el.innerHTML = `<span style="color:#000; font-weight:900; font-size:10px;">${mem.kelvin}K</span>`;
            } else {
                el.style.backgroundColor = '#000'; el.style.border = '1px solid var(--lcd-on)';
                let name = "FX";
                if(mem.fxMode <= 20 && CINEMA_FX[mem.fxMode]) name = CINEMA_FX[mem.fxMode];
                else if(SHNOPIA_FX[mem.fxMode-21]) name = SHNOPIA_FX[mem.fxMode-21];
                el.innerHTML = `<span style="color:var(--lcd-on); font-size:8px; text-align:center;">${name}</span>`;
            }
        }

        function toggleLiveSaveMode() {
            isLiveSaveMode = !isLiveSaveMode;
            const btn = document.getElementById('live-save-global-btn');
            if(isLiveSaveMode) {
                btn.style.backgroundColor = '#ff0000'; btn.style.color = '#fff'; btn.style.boxShadow = '0 0 15px #ff0000'; btn.style.borderColor = '#fff';
            } else {
                btn.style.backgroundColor = ''; btn.style.color = '#f5a623'; btn.style.boxShadow = ''; btn.style.borderColor = '#f5a623';
            }
        }

        function handleLivePadClick(index) {
            if (isLiveSaveMode) {
                saveLive(index);
                toggleLiveSaveMode();
            } else {
                recallLive(index);
            }
        }

        function saveLive(index) {
            if(isRecording) return; isRecording = true;
            liveMemory[index] = JSON.parse(JSON.stringify(state)); recallLive(index);
            
            const pad = document.getElementById(`live-pad-${index}`);
            pad.style.border = "2px solid #ff0000"; // Visual feedback
            
            const stream = canvas.captureStream(30); const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); const chunks = [];
            recorder.ondataavailable = (e) => { if(e.data.size > 0) chunks.push(e.data); };
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob);
                pad.innerHTML = ''; 
                const video = document.createElement('video'); video.className = 'pad-video'; video.src = url; 
                video.muted = true; video.loop = true; video.autoplay = true; video.playsInline = true;
                pad.appendChild(video); video.play(); 
                isRecording = false; 
                pad.style.border = ""; // Remove visual feedback
                if(selectedPadIndex === index) pad.classList.add('active-preset');
            };
            recorder.start(); setTimeout(() => { recorder.stop(); }, 2000);
        }

        function recallLive(index) {
            selectedPadIndex = index;
            document.querySelectorAll('.live-pad').forEach(p => p.classList.remove('active-preset'));
            const currentPad = document.getElementById(`live-pad-${index}`);
            if(currentPad) currentPad.classList.add('active-preset');
            if(liveMemory[index]) { state = JSON.parse(JSON.stringify(liveMemory[index])); syncUI(); }
        }

        function handleColorMemClick(index) {
            // D√©tection de l'onglet actif
            const isTextTab = document.getElementById('tab-text').classList.contains('visible');

            if (isColorSaveMode) {
                // --- MODE ENREGISTREMENT (REC) ---
                let hexToSave;

                if (isTextTab) {
                    // Si onglet Texte : on sauvegarde la couleur du TEXTE
                    hexToSave = state.textColor;
                } else {
                    // Sinon : on sauvegarde la couleur de la LUMI√àRE principale
                    let r, g, b;
                    if(state.mode === 'CCT') { r=state.whiteRgb.r; g=state.whiteRgb.g; b=state.whiteRgb.b; }
                    else { const rgb = hsvToRgb(state.hue, state.sat, state.val); r=rgb[0]; g=rgb[1]; b=rgb[2]; }
                    hexToSave = rgbToHex(r, g, b);
                }
                
                state.savedColors[index] = hexToSave; 
                isColorSaveMode = false; 
                updateMemoriesUI(); 

            } else {
                // --- MODE RAPPEL (LOAD) ---
                let hex = state.savedColors[index]; if(!hex.startsWith('#')) hex = '#' + hex;
                
                if (isTextTab) {
                    // Si onglet Texte : on applique au TEXTE seulement
                    state.textColor = hex;
                    document.getElementById('input-text-color').value = hex;
                } else {
                    // Sinon : on applique √† la LUMI√àRE principale
                    const rgb = hexToRgb(hex);
                    const activeTab = document.querySelector('.tab-btn.active');
                    
                    if (activeTab && activeTab.getAttribute('data-tr') === 'WHITE') {
                         state.whiteRgb = rgb;
                         updateWhiteUI(rgb);
                         activateStatic('CCT');
                    } else {
                        document.getElementById('input-r').value = rgb.r; document.getElementById('input-g').value = rgb.g; document.getElementById('input-b').value = rgb.b;
                        updateFromRGB(); 
                        activateStatic('WHEEL');
                    }
                }
            }
        }
        updateMemoriesUI();

        // RENDER ENGINE
        let stormFlash = 0;
        const RENDER_SCALE = 0.15; 
        let cachedWidth = 0, cachedHeight = 0;
        let imgData = null, buf32 = null; 

        const mix = (x, y, a) => x * (1 - a) + y * a;
        const clamp = (x, min, max) => Math.max(min, Math.min(max, x));
        const fract = (x) => x - Math.floor(x);
        const step = (edge, x) => x < edge ? 0 : 1;
        const smoothstep = (edge0, edge1, x) => { x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); return x * x * (3 - 2 * x); };
        const setP = (buf, i, r, g, b) => {
            r = r < 0 ? 0 : (r > 255 ? 255 : r); g = g < 0 ? 0 : (g > 255 ? 255 : g); b = b < 0 ? 0 : (b > 255 ? 255 : b);
            buf[i] = (255 << 24) | (b << 16) | (g << 8) | r;
        };
       const p = (ctx, idx, r, g, b, i, t) => {
    // Note: Le warp est maintenant g√©r√© dans la boucle principale (UV Warping)
    
    // Noise Texture (Grain filmique)
    if(ctx.noise > 0) { 
         let nVal = noise(ctx.u * 50, ctx.v * 50 + t*10); 
         let grain = (nVal - 0.5) * ctx.noise * 40;
         r+=grain; g+=grain; b+=grain;
    }

    if(ctx.usePalette) { 
        // 1. ANALYSE : On garde la structure Max pour la luminosit√© (votre demande pr√©c√©dente)
        let struct = Math.max(r, g, b) / 255; 
        
        if (struct > 0.05) {
            // 2. SLIDER C (Shift) : On ajoute ctx.pc pour d√©caler les couleurs de la palette
            let shift = ctx.pc * ctx.activeColors.length; 
            let palettePos = (struct * 2 + t * 0.2 + shift) * ctx.activeColors.length;
            
            let idx1 = Math.floor(palettePos);
            let idx2 = idx1 + 1;
            let amt = palettePos - idx1; 
            
            let c1 = ctx.activeColors[idx1 % ctx.activeColors.length];
            let c2 = ctx.activeColors[idx2 % ctx.activeColors.length];
            
            let finalR = c1.r * (1-amt) + c2.r * amt;
            let finalG = c1.g * (1-amt) + c2.g * amt;
            let finalB = c1.b * (1-amt) + c2.b * amt;

            let intensity = i * struct; 
            
            // 3. SLIDER B (Mix) : On r√©introduit le m√©lange
            // Si Param B (ctx.pb) est √† 100% (1.0), on remplace totalement. Si 0%, on garde l'original.
            let mixR = mix(finalR * intensity, r, 1 - ctx.pb);
            let mixG = mix(finalG * intensity, g, 1 - ctx.pb);
            let mixB = mix(finalB * intensity, b, 1 - ctx.pb);

            setP(ctx.buf, idx, mixR, mixG, mixB);
        } else { setP(ctx.buf, idx, 0,0,0); }
    } else { setP(ctx.buf, idx, r*i, g*i, b*i); }
};
        const hsl = (ctx, idx, h, s, l, t) => { const rgb = hslToRgb(h, s, l); p(ctx, idx, rgb[0], rgb[1], rgb[2], 1, t); };
        const plasmaGen = (ctx, idx, t, baseHue, speed, zoom) => {
            let z = zoom * ctx.pa; 
            let raw = Math.sin(ctx.u * 10 * z + t * speed) + Math.cos(ctx.v * 10 * z + t * speed);
            // Param C: Nettet√© / Contraste (0 = flou, 1 = dur)
            let contrast = 1 + ctx.pc * 10;
            let val = Math.max(-1, Math.min(1, raw * contrast)); 
            let hue = (baseHue + ctx.pb * 180 + val * 20) % 360; 
            hsl(ctx, idx, hue, 100, 50 + val * 40, t);
        };

        const FX_RENDERERS = {
            // --- LIGNE 1 : CLASSIQUES ---
            0: (c, i, t) => p(c, i, c.rB, c.gB, c.bB, 1, t), // Static
            1: (c, i, t) => { let w = mix(0.2, 0.8, c.pc); let s = step(w, fract(c.u)); let r = (step(0.5, fract(t * c.pa)) ^ s); p(c, i, r?255:0, 0, r?0:255, 1, t); }, // Police
            2: (c, i, t) => { let n = (Math.sin(t*10 + c.u*10*c.pa) + Math.sin(t*20 + c.v*10*c.pa))*0.5+0.5; let h = n + c.pc*0.5; p(c, i, 255, mix(50, 255, h)+100*c.pb, 50*c.pb, mix(0.5, 1.0, n), t); }, // Fire
            3: (c, i, t, rnd) => { let f = step(0.99 - c.pa*0.04, rnd); p(c, i, 255, mix(255, 205, c.pb), mix(255, 105, c.pb), Math.max(f, c.pc*0.2), t); }, // Paparazzi

            // --- LIGNE 2 : SCINTILLEMENTS ---
            4: (c, i, t) => { let d = (Math.sin(c.v*50 + t)*0.01)*c.pc; let s = step(0.1, fract(c.v + t + d)); p(c, i, 200, 220-100*c.pb, 255, mix(0.8, 0.4, s), t); }, // TV
            5: (c, i, t, rnd) => { let s = (Math.sin(t*10)>0.5 && rnd > 0.5/c.pa) ? 1 : 0.05+c.pc*0.2; p(c, i, 200, 230, 255-200*c.pb, s, t); }, // Welding
            6: (c, i, t) => { let h = mix(0.01, 0.5, c.pc); let b = 1-smoothstep(0, h/c.pa, Math.abs(c.u - fract(t*0.5))); p(c, i, 255, 180, 100+155*c.pb, b, t); }, // Process
            7: (c, i, t, rnd) => { let f = (rnd > 0.5*c.pa || Math.sin(t)>0.8) ? (1-c.pc) : 1; p(c, i, 220, 255, 220-200*c.pb, f, t); }, // Bad Bulb

            // --- LIGNE 3 : AMBIANCE ---
            8: (c, i, t) => { let bg = c.pc*50; p(c, i, 255-50*c.pb, 255-200*c.pb, 255, Math.max(bg/255, stormFlash), t); }, // Storm
            9: (c, i, t) => { let w = c.pc*0.3; let f = 0.6 + (Math.sin(t*10) + Math.sin(t*20*c.pa))*(0.1+w); p(c, i, 255, 150-50*c.pb, 50, f, t); }, // Candle
            10: (c, i, t, rnd) => { let d = mix(0.1, 0.9, c.pc); let o = step(1-d, fract(t*c.pa)); if(c.pb>0.1 && rnd<c.pb) p(c,i,rnd*255,rnd*255,rnd*255,o,t); else p(c,i,255,255,255,o,t); }, // Strobe
            11: (c, i, t) => { let age = t%3; if(age<0.2) p(c,i,255,255,255,1,t); else { let d=1-(age-0.2)*(1-c.pc); p(c,i,255,100+155*c.pb,100*c.pb,clamp(d,0,1),t); } }, // Explosion

            // --- LIGNE 4 : MOUVEMENT ---
            12: (c, i, t) => hsl(c, i, (t*50 + c.x*c.pa)%360, 100-50*c.pb, 50*(1+Math.sin(t*10)*c.pc), t), // Club
            13: (c, i, t) => { let a = Math.atan2(c.v-0.5, c.u-0.5)+t*(5+c.pc*5); let b = Math.sin(a)>0; p(c, i, b?0:255, 0, b?255:0, 1, t); }, // Emergency
            14: (c, i, t) => { let s = mix(0.1, 0.5, c.pc); let f = step(s*c.pa, fract(c.v+t*0.5)); p(c, i, 255, 200-200*c.pb, 150-150*c.pb, 1-f, t); }, // Elevator
            15: (c, i, t, rnd) => { let d = (rnd > (0.9-c.pc*0.5)) ? 0 : 1; p(c, i, 50+50*c.pb, 100, 50, d*(0.5+0.5*c.pb), t); }, // Horror

            // --- LIGNE 5 : SHNOPIA DIGITAL ---
            16: (c, i, t) => plasmaGen(c, i, t, 140, 1.0, 1.0), // Aurora
            17: (c, i, t, rnd) => { let d = fract(c.v+t*c.pa); let h = step(0.1*c.pa*(1+c.pc), Math.abs(c.v-d)); hsl(c, i, 120+180*c.pb, 100, (h<1 && rnd>0.8)?50:0, t); }, // Matrix
            18: (c, i, t) => { let g = step(0.1+c.pc*0.2, fract(c.u*c.pa + c.v*c.pa)); hsl(c, i, g?180+180*c.pb:300, 100, 30+Math.sin(t*5)*20, t); }, // Cyber
            19: (c, i, t) => plasmaGen(c, i, t, 0, 1.0, 1.0), // Plasma (Variable)

            // --- LIGNE 6 : SHNOPIA GEO ---
            20: (c, i, t) => plasmaGen(c, i, t, 200, 1.5, 2.0), // Disco
            21: (c, i, t) => plasmaGen(c, i, t, 10, 0.8, 0.8), // Bifrost
            22: (c, i, t) => hsl(c, i, 280 - c.v*60*c.pa + 100*c.pb, 80+c.pc*20, 50, t), // Scanner
            23: (c, i, t) => plasmaGen(c, i, t, 260, 0.5, 1.0), // Ripple

            // --- LIGNE 7 : SHNOPIA TEXTURE ---
            24: (c, i, t, rnd) => { let d = 0.95/c.pa - (c.pc*0.1); let f = step(d, rnd); p(c, i, 255-100*c.pb, 255, 255, f, t); }, // Snow
            25: (c, i, t, rnd) => { if(rnd > 0.9/c.pa) hsl(c, i, rnd*360, 100, 50, t); else p(c, i, 0, 255*c.pb, 0, 1-c.pc, t); }, // Glitch
            26: (c, i, t) => { let b = (Math.floor(c.u*10*c.pa + c.v*10*c.pa + t)%2); p(c, i, 0, 255, 100*c.pb, b*(1+c.pc), t); }, // Binary
            27: (c, i, t) => { let s = 10/c.pa + c.pc*10; let b = Math.pow(Math.sin(t*5)*0.5+0.5, s); p(c, i, 255, 255*c.pb, 255*c.pb, b, t); }, // Heartbeat

            // --- LIGNE 8 : SHNOPIA ABSTRACT ---
            28: (c, i, t) => { let tun = step(c.v*c.pa*(1-c.pc*0.5), Math.abs(c.u-0.5)); p(c, i, 255-200*c.pb, 255, 255, tun, t); }, // Warp
            29: (c, i, t, rnd) => hsl(c, i, 220+40*c.pb, 100, (rnd > 0.9/c.pa)?80:c.pc*20, t), // Rain
            30: (c, i, t) => { let a = Math.atan2(c.v-0.5, c.u-0.5); hsl(c, i, a*50*c.pa + 180*c.pb, 100, 50+c.pc*20, t); }, // Vortex
            31: (c, i, t) => { let sym = Math.abs(c.u-0.5)*Math.abs(c.v-0.5); hsl(c, i, (sym*100*c.pa + t*100 + 180*c.pb)%360, 100, 50+c.pc*50, t); } // Kaleido
        };

        function render() {
            if(state.blackout) { 
                ctx.fillStyle = "black"; if(canvas.width > 1) ctx.fillRect(0, 0, canvas.width, canvas.height);
                textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height); requestAnimationFrame(render); return; 
            }
            let rawW = window.innerWidth, rawH = window.innerHeight;
            let targetW, targetH;
            if (state.mapMode >= 0) { targetW = state.renderW || 1; targetH = state.renderH || 1; } 
            else { targetW = Math.floor(rawW * RENDER_SCALE); targetH = Math.floor(rawH * RENDER_SCALE); if(targetW < 1) targetW = 1; if(targetH < 1) targetH = 1; }

            if(cachedWidth !== targetW || cachedHeight !== targetH) {
                canvas.width = targetW; canvas.height = targetH; cachedWidth = targetW; cachedHeight = targetH;
                canvas.style.imageRendering = (state.mapMode >= 0) ? 'pixelated' : 'auto';
                imgData = ctx.createImageData(targetW, targetH); buf32 = new Uint32Array(imgData.data.buffer);
            }
            if(textCanvas.width !== rawW || textCanvas.height !== rawH) { textCanvas.width = rawW; textCanvas.height = rawH; }

            state.time += (state.speed / 50) * 0.05; const t = state.time; 
            state.textTime += 0.04; const tt = state.textTime;
            let pa = Math.max(0.1, state.fxParam1 / 50); let pb = state.fxParam2 / 100; let pc = state.fxParam3 / 100;

            if(state.fxMode === 8) { 
                if(Math.random() > (0.99 - (pa * 0.01))) stormFlash = 1; else stormFlash *= 0.85; if(stormFlash < 0.01) stormFlash = 0.02; 
            }

            const activeColors = state.savedColors.filter((c, i) => state.paletteActive[i]).map(hex => hexToRgb(hex));
            const renderCtx = { buf: buf32, w: targetW, h: targetH, u: 0, v: 0, vPos: 0, warp: state.warpActive ? state.warpLevel : 0, noise: state.noiseActive ? state.noiseLevel : 0, pa: pa, pb: pb, pc: pc, rB: 0, gB: 0, bB: 0, activeColors: activeColors, usePalette: activeColors.length > 0 && state.fxMode !== 0 };

            if (state.mode === 'WHEEL') { const rgb = hsvToRgb(state.hue, state.sat, state.val); renderCtx.rB=rgb[0]; renderCtx.gB=rgb[1]; renderCtx.bB=rgb[2]; } 
            else if (state.mode === 'CCT') { renderCtx.rB=state.whiteRgb.r; renderCtx.gB=state.whiteRgb.g; renderCtx.bB=state.whiteRgb.b; }

            let renderFn = FX_RENDERERS[state.fxMode] || FX_RENDERERS[0];
            let idx32 = 0;
            
            // Pr√©-calcul du Warping pour optimiser
            let doWarp = state.warpActive && state.warpLevel > 0;
            let warpScale = state.warpLevel * 0.1; // Force du warp
            let warpTime = t * 0.5;

            for(let y=0; y<targetH; y++) {
                let vBase = (y + 0.5) / targetH;
                renderCtx.vPos = y;

                for(let x=0; x<targetW; x++) { 
                    let uBase = (x + 0.5) / targetW;
                    
                    if (doWarp) {
                        // DOMAIN WARPING : On tord l'espace avec du bruit et des sinus
                        // Cela transforme les lignes droites en liquide
                        let noiseVal = noise(uBase * 3 + warpTime, vBase * 3 - warpTime);
                        renderCtx.u = uBase + Math.sin(vBase * 10 + warpTime) * warpScale * noiseVal;
                        renderCtx.v = vBase + Math.cos(uBase * 10 + warpTime) * warpScale * noiseVal;
                    } else {
                        renderCtx.u = uBase;
                        renderCtx.v = vBase;
                    }

                    // On appelle l'effet avec les coordonn√©es tordues (renderCtx.u/v)
                    // Mais on √©crit dans le pixel physique correct (idx32)
                    renderFn(renderCtx, idx32, t, Math.random()); 
                    idx32++; 
                }
            }
            ctx.putImageData(imgData, 0, 0);
            if(state.dimmer < 100) { ctx.fillStyle=`rgba(0,0,0, ${1-state.dimmer/100})`; ctx.fillRect(0,0,targetW,targetH); }

            textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            if(state.textOn && state.textString) {
                const fontSize = Math.max(20, textCanvas.height * (state.textSize/100));
                textCtx.font = `bold ${fontSize}px ${state.textFont}`; 
                textCtx.fillStyle = state.textColor; 
                textCtx.textBaseline = "middle"; 
                textCtx.globalAlpha = state.dimmer / 100;

                // 1. D√âCOUPAGE LIGNES & CALCULS
                const lines = state.textString.split('\n');
                const lineHeight = fontSize * 1.2;
                
                // Calcul de la ligne la plus longue pour le scroll
                let maxLineWidth = 0;
                lines.forEach(line => { const w = textCtx.measureText(line).width; if(w > maxLineWidth) maxLineWidth = w; });

                // Gestion Scroll
                if(state.textSpeed > 0) { 
                    const speed = (state.textSpeed / 10) * (textCanvas.width / 100) + 0.1; 
                    state.textPos -= speed; 
                    if(state.textPos < -maxLineWidth) state.textPos = textCanvas.width; 
                } else { 
                    state.textPos = (textCanvas.width - maxLineWidth) / 2; 
                }

                // Centrage vertical du BLOC complet
                const startY = (textCanvas.height / 2) - ((lines.length - 1) * lineHeight) / 2;
                const lvl = state.textFxLvl / 100;

                // 2. BOUCLE DE DESSIN PAR LIGNE
                lines.forEach((lineText, index) => {
                    const y = startY + (index * lineHeight);
                    let x = state.textPos;

                    // Si pas de scroll, on centre chaque ligne individuellement pour faire "propre"
                    if(state.textSpeed === 0) {
                        const lineWidth = textCtx.measureText(lineText).width;
                        x = (textCanvas.width - lineWidth) / 2;
                    }

                    // APPLICATION DES EFFETS (Adapt√© pour multiligne)
                    if(state.textEffect === "NONE") { textCtx.fillText(lineText, x, y); }
                    else if(state.textEffect === "NEON") { textCtx.shadowBlur = 20 * lvl + 5; textCtx.shadowColor = state.textColor; textCtx.fillStyle = "#ffffff"; textCtx.fillText(lineText, x, y); textCtx.shadowBlur = 0; }
                    else if(state.textEffect === "GLITCH") { if(Math.random() < lvl) { textCtx.fillStyle = "red"; textCtx.fillText(lineText, x + (Math.random()-0.5)*10*lvl, y); textCtx.fillStyle = "blue"; textCtx.fillText(lineText, x, y + (Math.random()-0.5)*10*lvl); } textCtx.fillStyle = state.textColor; textCtx.fillText(lineText, x, y); }
                    else if(state.textEffect === "WAVE") { textCtx.fillStyle = state.textColor; for (let i = 0; i < lineText.length; i++) { const char = lineText[i]; const yOff = Math.sin(tt*5 + i*0.5 + index) * (50 * lvl); textCtx.fillText(char, x + (i*fontSize*0.6), y + yOff); } }
                    else if(state.textEffect === "TYPE") { const len = Math.floor(lineText.length * ((Math.sin(tt)+1)/2)); textCtx.fillText(lineText.substring(0, len), x, y); }
                    else if(state.textEffect === "STROKE") { textCtx.lineWidth = 2 + 5*lvl; textCtx.strokeStyle = state.textColor; textCtx.strokeText(lineText, x, y); }
                    else if(state.textEffect === "MIRROR") { textCtx.fillText(lineText, x, y); textCtx.save(); textCtx.scale(1, -1); textCtx.globalAlpha = 0.3; textCtx.fillText(lineText, x, -y + (fontSize*0.8)); textCtx.restore(); }
                    else if(state.textEffect === "SHAKE") { const ox = (Math.random()-0.5)*20*lvl; const oy = (Math.random()-0.5)*20*lvl; textCtx.fillText(lineText, x+ox, y+oy); }
                    else if(state.textEffect === "RAINBOW") { textCtx.fillStyle = `hsl(${(tt*100 + index*50)%360}, 100%, 50%)`; textCtx.fillText(lineText, x, y); }
                    else if(state.textEffect === "BOUNCE") { const by = Math.abs(Math.sin(tt*5 + index))*100*lvl; textCtx.fillText(lineText, x, y - by + (50*lvl)); }
                    else if(state.textEffect === "BREATHE") { const scale = 1 + Math.sin(tt*3)*0.3*lvl; textCtx.save(); textCtx.translate(x + maxLineWidth/2, y); textCtx.scale(scale, scale); textCtx.translate(-(x + maxLineWidth/2), -y); textCtx.fillText(lineText, x, y); textCtx.restore(); }
                    
                    // Reset apr√®s chaque ligne
                    textCtx.globalAlpha = state.dimmer / 100;
                    if(state.textEffect === "NEON") textCtx.fillStyle = "#ffffff"; // Reset fill pour neon
                    else textCtx.fillStyle = state.textColor;
                });
                textCtx.globalAlpha = 1;
            }
            previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height); previewCtx.drawImage(canvas, 0, 0, previewCanvas.width, previewCanvas.height);
            requestAnimationFrame(render);
        }

        window.switchTab = (id, btn) => { 
            document.querySelectorAll('.panel-content').forEach(e => e.classList.remove('visible')); 
            document.getElementById(id).classList.add('visible'); 
            document.querySelectorAll('.tab-btn').forEach(e => e.classList.remove('active')); 
            if(btn) btn.classList.add('active'); 
            if(id === 'tab-wheel') setTimeout(updateCursorVisuals, 50);
        };
        
        window.setEffect = (id, el) => { 
            if (id === 0) { activateStatic('WHEEL'); } 
            else { 
                state.fxMode = id; state.mode = 'FX'; 
                document.querySelectorAll('.fx-card').forEach(c => c.classList.remove('active')); el.classList.add('active'); 
                
                // CALIBRAGE DES PRESETS (A=Struct/Vit, B=Couleur/Mix, C=Dyn/Seuil)
                const presets = {
                    // Classiques
                    1: {a: 60, b: 0, c: 50}, // Police (Bleu/Rouge pur)
                    2: {a: 35, b: 20, c: 80}, // Fire (Lent, Orange/Rouge chaud, intense)
                    3: {a: 85, b: 0, c: 10},  // Paparazzi (Rapide, Blanc, Flash court)
                    
                    // Scintillements
                    4: {a: 60, b: 40, c: 5},  // TV (Froid bleut√©, distorsion subtile)
                    5: {a: 95, b: 5, c: 0},   // Welding (Tr√®s chaotique, pointe de bleu, flash sec)
                    6: {a: 50, b: 50, c: 50}, // Process
                    7: {a: 40, b: 90, c: 70}, // Bad Bulb (Lent, Chaud Tungst√®ne, scintillement marqu√©)

                    // Ambiance
                    8: {a: 95, b: 0, c: 5},   // Storm (Orages rares, Blanc, Fond sombre)
                    9: {a: 20, b: 85, c: 30}, // Candle (Calme, Tr√®s chaud/Orange, scintillement doux)
                    10: {a: 100,b: 100,c:50}, // Strobe (Max speed, Blanc)
                    11: {a: 10, b: 15, c: 10},// Explosion (Lent, Blanc chaud)

                    // Mouvement
                    12: {a: 50, b: 50, c: 50}, // Club
                    13: {a: 50, b: 0, c: 0},   // Emergency (Rotatif, Bleu/Rouge)
                    14: {a: 20, b: 20, c: 50}, // Elevator
                    15: {a: 80, b: 0, c: 50},  // Horror

                    // Shnopia Digital
                    16: {a: 25, b: 50, c: 50}, // Aurora
                    17: {a: 60, b: 0, c: 80},  // Matrix (Vert)
                    18: {a: 50, b: 50, c: 20}, // Cyber
                    19: {a: 40, b: 50, c: 50}, // Plasma (Neutre)

                    // Geo & Texture
                    24: {a: 80, b: 20, c: 20}, // Snow (Rapide, Blanc froid)
                    25: {a: 90, b: 30, c: 50}, // Glitch
                    27: {a: 60, b: 0, c: 90},  // Heartbeat (Rouge, net)
                    
                    // Abstract
                    29: {a: 90, b: 30, c: 50}, // Rain (Bleut√©)
                };
                
                const p = presets[id] || {a: 50, b: 50, c: 50}; 
                updateFxParam(1, p.a); updateFxParam(2, p.b); updateFxParam(3, p.c);
            }
        };
        
        window.setKelvin = (k, btn) => { 
            state.kelvin = k; const inputK = document.getElementById('input-kelvin'); inputK.value = k; updateRangeStyle(inputK);
            document.getElementById('val-kelvin').innerText = k + "K";
            const rgb = applyTint(kelvinToRgb(k), state.tint); updateWhiteUI(rgb); activateStatic('CCT'); 
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active')); if(btn) btn.classList.add('active');
        };

        window.setMapMode = (idx, el) => {
            state.mapMode = idx - 1; 
            document.querySelectorAll('.map-btn').forEach(b => b.classList.remove('active-map')); if (el) el.classList.add('active-map'); 
            updateMatrixDisplays();
        };

        window.toggleMatrixDimension = () => {
            if (state.mapMode >= 0 && state.mapMode < MAPS.length) {
                const map = MAPS[state.mapMode]; let tempW = map.w; map.w = map.h; map.h = tempW;
                updateMatrixDisplays();
            }
        };

       function updateMatrixDisplays() {
            const displayMat = document.getElementById('matrix-display'); const displayCells = document.getElementById('cells-display');
            const containerCells = document.getElementById('cells-container'); const labelSlider = document.getElementById('val-grid-lvl');
            
            if(containerCells) {
                containerCells.classList.remove('active-preset'); containerCells.style.borderColor = '#005500';
                containerCells.style.boxShadow = 'inset 0 0 15px rgba(0,0,0,0.8)'; containerCells.style.animation = 'none';
            }
            if(displayCells) displayCells.style.color = 'var(--lcd-on)';
            
            if (state.mapMode >= 0 && state.mapMode < MAPS.length) {
                const map = MAPS[state.mapMode]; let lvl = parseInt(state.gridLevel);
                let finalW, finalH, infoText;
                if (lvl === 0) { finalW = map.w; finalH = map.h; infoText = "NATIVE"; if(labelSlider) labelSlider.style.color = "#888"; } 
                else if (lvl > 0) { let factor = lvl + 1; finalW = map.w * factor; finalH = map.h * factor; infoText = "MULT x" + factor; if(labelSlider) labelSlider.style.color = "#0f0"; } 
                else { let factor = Math.abs(lvl) + 1; finalW = Math.round(map.w / factor); finalH = Math.round(map.h / factor); if (finalW < 1) finalW = 1; if (finalH < 1) finalH = 1; infoText = "DIV /" + factor; if(labelSlider) labelSlider.style.color = "#ffaa00"; }

                state.renderW = finalW; state.renderH = finalH;
                if(labelSlider) labelSlider.innerText = infoText;
                if(displayMat) displayMat.innerText = `${finalW}x${finalH}`;
                
                const cells = finalW * finalH; if(displayCells) displayCells.innerText = cells.toLocaleString('fr');
                
                if (cells > 400 && containerCells) {
                    displayCells.style.color = '#ff0000'; displayCells.style.textShadow = '0 0 10px #ff0000';
                    containerCells.style.borderColor = '#ff0000'; containerCells.style.boxShadow = '0 0 20px rgba(255, 0, 0, 0.4), inset 0 0 10px rgba(255,0,0,0.2)';
                    containerCells.style.animation = 'pulse 0.5s infinite alternate';
                }
            } else { if(displayMat) displayMat.innerText = "N/A"; if(displayCells) displayCells.innerText = "N/A"; }
        }

        window.activateStatic = (mode) => {
            state.fxMode = 0; state.mode = mode; 
            document.querySelectorAll('.fx-card').forEach(c => c.classList.remove('active'));
            if(document.getElementById('fx-static')) document.getElementById('fx-static').classList.add('active');
        };
        
        window.recallWhite = () => {
            const rgb = state.whiteRgb;
            document.getElementById('input-r').value = Math.round(rgb.r); document.getElementById('input-g').value = Math.round(rgb.g); document.getElementById('input-b').value = Math.round(rgb.b);
            updateFromRGB(); activateStatic('WHEEL');
        };

        function updateRangeStyle(input) {
            const val = (input.value - input.min) / (input.max - input.min) * 100;
            let color = 'var(--lcd-on)';
            
            // MODIFICATION: Si c'est Kelvin ou Tint, on utilise la couleur blanche actuelle
            if (input.id === 'input-kelvin' || input.id === 'input-tint') {
                // On r√©cup√®re la couleur calcul√©e stock√©e dans l'√©tat global
                if (state.whiteRgb) {
                    color = rgbToHex(state.whiteRgb.r, state.whiteRgb.g, state.whiteRgb.b);
                }
            }
            else if(input.id.includes('-r')) color = '#ff3333'; 
            else if(input.id.includes('-g')) color = '#33ff33'; 
            else if(input.id.includes('-b')) color = '#3388ff';
            
            input.style.backgroundImage = `linear-gradient(to right, ${color} 0%, ${color} ${val}%, #004400 ${val}%, #004400 100%)`;
        }

        window.updateGridSlider = (el) => { state.gridLevel = parseInt(el.value); state.gridActive = (state.gridLevel > 1); document.getElementById('val-grid-lvl').innerText = `x${state.gridLevel}`; updateRangeStyle(el); };
        window.updateWarpSlider = (el) => { state.warpLevel = parseInt(el.value); state.warpActive = (state.warpLevel > 0); document.getElementById('val-warp-lvl').innerText = state.warpLevel; updateRangeStyle(el); };
        window.updateNoiseSlider = (el) => { state.noiseLevel = parseInt(el.value); state.noiseActive = (state.noiseLevel > 0); document.getElementById('val-noise-lvl').innerText = state.noiseLevel; updateRangeStyle(el); };

        let modMemories = [null, null, null];
        let isModSaveMode = false;

        window.resetModifiers = () => {
            state.gridLevel = 0; state.warpLevel = 0; state.noiseLevel = 0;
            state.gridActive = false; state.warpActive = false; state.noiseActive = false;
            syncUI();
        };

        window.toggleModSaveMode = () => {
            isModSaveMode = !isModSaveMode;
            const btn = document.getElementById('mod-save-btn');
            if(isModSaveMode) {
                btn.style.backgroundColor = '#ff0000'; btn.style.color = '#fff'; btn.style.boxShadow = '0 0 15px #ff0000'; btn.style.borderColor = '#fff';
            } else {
                btn.style.backgroundColor = ''; btn.style.color = '#f5a623'; btn.style.boxShadow = ''; btn.style.borderColor = '#f5a623';
            }
        };

        window.handleModMemClick = (idx) => {
            const btn = document.getElementById(`mod-mem-${idx}`);
            if(isModSaveMode) {
                // SAVE MODE
                modMemories[idx] = { g: state.gridLevel, w: state.warpLevel, n: state.noiseLevel };
                
                // Visual feedback (Green flash 1s)
                btn.style.transition = 'none'; 
                btn.style.backgroundColor = '#00ff00'; 
                btn.style.color = '#000'; 
                btn.style.boxShadow = '0 0 15px #00ff00';
                
                setTimeout(() => { 
                    btn.style.transition = ''; 
                    btn.style.backgroundColor = ''; 
                    btn.style.color = ''; 
                    btn.style.boxShadow = ''; 
                    // Apply permanent glow
                    btn.classList.add('mem-stored');
                }, 1000);
                
                toggleModSaveMode(); // Exit save mode automatically
            } else {
                // RECALL MODE
                if(modMemories[idx]) {
                    state.gridLevel = modMemories[idx].g; state.warpLevel = modMemories[idx].w; state.noiseLevel = modMemories[idx].n;
                    state.gridActive = (state.gridLevel > 1); state.warpActive = (state.warpLevel > 0); state.noiseActive = (state.noiseLevel > 0);
                    syncUI();
                    // Blink effect trick to show activation even if already glowing
                    btn.classList.remove('mem-stored'); 
                    void btn.offsetWidth; // Trigger reflow
                    btn.classList.add('active'); 
                    btn.classList.add('mem-stored');
                    setTimeout(()=>btn.classList.remove('active'), 200);
                }
            }
        };

        // --- FX MEMORY SYSTEM ---
        let fxMemories = [null, null, null];
        let isFxSaveMode = false;

        window.resetFxSettings = () => {
            // On r√©initialise seulement les param√®tres, on garde l'effet actif
            state.speed = 4;
            state.fxParam1 = 50; state.fxParam2 = 50; state.fxParam3 = 50;
            state.paletteActive = [false, false, false, false, false]; 
            syncUI();
        };

        window.toggleFxSaveMode = () => {
            isFxSaveMode = !isFxSaveMode;
            const btn = document.getElementById('fx-save-btn');
            if(isFxSaveMode) {
                btn.style.backgroundColor = '#ff0000'; btn.style.color = '#fff'; btn.style.boxShadow = '0 0 15px #ff0000'; btn.style.borderColor = '#fff';
            } else {
                btn.style.backgroundColor = ''; btn.style.color = '#f5a623'; btn.style.boxShadow = ''; btn.style.borderColor = '#f5a623';
            }
        };

        window.handleFxMemClick = (idx) => {
            const btn = document.getElementById(`fx-mem-${idx}`);
            if(isFxSaveMode) {
                // SAVE
                fxMemories[idx] = { 
                    mode: state.fxMode, 
                    spd: state.speed, 
                    p1: state.fxParam1, p2: state.fxParam2, p3: state.fxParam3,
                    pal: [...state.paletteActive] // Sauvegarde aussi la palette active
                };
                
                // Visual feedback
                btn.style.transition = 'none'; btn.style.backgroundColor = '#00ff00'; btn.style.color = '#000'; btn.style.boxShadow = '0 0 15px #00ff00';
                setTimeout(() => { 
                    btn.style.transition = ''; btn.style.backgroundColor = ''; btn.style.color = ''; btn.style.boxShadow = ''; 
                    btn.classList.add('mem-stored');
                }, 1000);
                toggleFxSaveMode(); 
            } else {
                // RECALL
                if(fxMemories[idx]) {
                    const m = fxMemories[idx];
                    state.fxMode = m.mode; state.mode = (m.mode === 0) ? 'WHEEL' : 'FX';
                    state.speed = m.spd;
                    state.fxParam1 = m.p1; state.fxParam2 = m.p2; state.fxParam3 = m.p3;
                    if(m.pal) state.paletteActive = [...m.pal];
                    
                    syncUI();
                    
                    btn.classList.remove('mem-stored'); void btn.offsetWidth; btn.classList.add('active'); btn.classList.add('mem-stored');
                    setTimeout(()=>btn.classList.remove('active'), 200);
                }
            }
        };

        window.updateTextSlider = () => { const val = parseInt(document.getElementById('input-text-fx-lvl').value); state.textFxLvl = val; document.getElementById('val-text-fx-lvl').innerText = val + "%"; updateRangeStyle(document.getElementById('input-text-fx-lvl')); };
        
        window.toggleBlackout = () => { state.blackout = !state.blackout; const btn = document.getElementById('btn-blackout'); if(state.blackout) btn.classList.add('active'); else btn.classList.remove('active'); };
        window.toggleFS = () => { !document.fullscreenElement ? document.documentElement.requestFullscreen() : document.exitFullscreen(); };
        window.togglePreviewFS = () => { minimizePanel(); if(!document.fullscreenElement) document.documentElement.requestFullscreen(); };
        document.addEventListener("fullscreenchange", () => { const btn = document.querySelector('.fullscreen-btn'); if (document.fullscreenElement) btn.classList.add('active'); else btn.classList.remove('active'); });
        window.toggleText = () => { 
            state.textOn = !state.textOn; const d = DICT[CURRENT_LANG]; const btn = document.getElementById('btn-text-toggle'); 
            if(state.textOn) { btn.innerText = d.TEXT_ON; btn.classList.add('active'); state.textPos = textCanvas.width; } else { btn.innerText = d.TEXT_OFF; btn.classList.remove('active'); } 
        };
        // SHNOPIA MAGIC : On cache la souris quand le panel est cach√© !
        window.minimizePanel = () => { document.getElementById('main-panel').classList.add('hidden'); document.body.style.cursor = 'none'; };
        window.restorePanel = () => { document.getElementById('main-panel').classList.remove('hidden'); document.body.style.cursor = 'auto'; };
        
        function handleGlobalClick(e) { 
            const panel = document.getElementById('main-panel'); const langMenu = document.getElementById('lang-menu');
            if(langMenu.classList.contains('show') && e.target.className !== 'lang-icon') langMenu.classList.remove('show');
            if (panel.classList.contains('hidden')) { restorePanel(); } else { if (e.target.id !== 'modal-overlay') { minimizePanel(); if (!document.fullscreenElement) document.documentElement.requestFullscreen(); } } 
        }
        window.showCustomMatrixModal = () => { document.getElementById('modal-overlay').style.display = 'flex'; };
        window.closeModalOnOutside = (e) => { if(e.target.id === 'modal-overlay') document.getElementById('modal-overlay').style.display = 'none'; };
        
        window.applyCustomMatrix = () => {
            const w = parseInt(document.getElementById('custom-w').value) || 1; const h = parseInt(document.getElementById('custom-h').value) || 1;
            const setIndex = MAPS.findIndex(m => m.name === "SET");
            if (setIndex > -1) {
                MAPS[setIndex].w = w; MAPS[setIndex].h = h; const gridIndex = setIndex + 1; const btn = document.getElementById('btn-set');
                if(btn) { btn.innerHTML = `<span style="font-size:14px; margin-bottom:2px;">SET</span><span id="set-display" class="map-set-display" style="font-size:9px;">Matrice ${w}x${h}</span>`; setMapMode(gridIndex, btn); }
                document.getElementById('modal-overlay').style.display = 'none';
            }
        };

        document.getElementById('text-content').oninput = e => state.textString = e.target.value;
        document.getElementById('input-text-size').oninput = e => { state.textSize = parseInt(e.target.value); document.getElementById('val-text-size').innerText = state.textSize + "%"; updateRangeStyle(e.target); };
        document.getElementById('input-text-speed').oninput = e => { state.textSpeed = parseInt(e.target.value); document.getElementById('val-text-speed').innerText = state.textSpeed; updateRangeStyle(e.target); };
        document.getElementById('input-text-color').oninput = e => state.textColor = e.target.value;
        document.getElementById('input-text-font').onchange = e => state.textFont = e.target.value;
        document.getElementById('input-text-effect').onchange = e => state.textEffect = e.target.value;
        
        function linkInputRange(inputId, rangeId, updateFunc) {
            const input = document.getElementById(inputId); const range = document.getElementById(rangeId);
            input.addEventListener('change', () => { 
                let val = parseInt(input.value); if(isNaN(val)) val = 0; if(val < 0) val = 0; if(val > parseInt(input.max)) val = parseInt(input.max);
                input.value = val; range.value = val; updateRangeStyle(range); updateFunc(); 
            });
        }
        
        linkInputRange('val-sat-input', 'input-sat', () => { 
            state.sat = document.getElementById('input-sat').value; state.val = 100;
            const rgb = hsvToRgb(state.hue, state.sat, state.val); document.getElementById('hex-input').value = rgbToHex(rgb[0], rgb[1], rgb[2]); updateRGBInputs(rgb);
            updateCursorVisuals(); activateStatic('WHEEL');
        });
        
        linkInputRange('val-r-input', 'input-r', () => { updateFromRGB(); activateStatic('WHEEL'); });
        linkInputRange('val-g-input', 'input-g', () => { updateFromRGB(); activateStatic('WHEEL'); });
        linkInputRange('val-b-input', 'input-b', () => { updateFromRGB(); activateStatic('WHEEL'); });
        linkInputRange('val-white-r-input', 'input-white-r', updateFromWhiteRGB);
        linkInputRange('val-white-g-input', 'input-white-g', updateFromWhiteRGB);
        linkInputRange('val-white-b-input', 'input-white-b', updateFromWhiteRGB);
        linkInputRange('val-dimmer-input', 'input-dimmer', () => { state.dimmer = parseInt(document.getElementById('input-dimmer').value); });
        linkInputRange('val-speed-input', 'input-speed', () => { state.speed = parseInt(document.getElementById('input-speed').value); });
        
        document.getElementById('input-dimmer').oninput = e => { state.dimmer = parseInt(e.target.value); document.getElementById('val-dimmer-input').value = state.dimmer; updateRangeStyle(e.target); };
        document.getElementById('input-speed').oninput = e => { state.speed = parseInt(e.target.value); document.getElementById('val-speed-input').value = state.speed; updateRangeStyle(e.target); };
        
        document.getElementById('input-sat').oninput = e => { 
            state.sat = e.target.value; state.val = 100; document.getElementById('val-sat-input').value = state.sat; 
            const rgb = hsvToRgb(state.hue, state.sat, state.val); document.getElementById('hex-input').value = rgbToHex(rgb[0], rgb[1], rgb[2]); updateRGBInputs(rgb);
            updateCursorVisuals(); activateStatic('WHEEL'); updateRangeStyle(e.target);
        };
        
        document.getElementById('input-kelvin').oninput = e => { state.kelvin = parseInt(e.target.value); updateCCT(); updateRangeStyle(e.target); };
        document.getElementById('input-tint').oninput = e => { state.tint = e.target.value; updateCCT(); updateRangeStyle(e.target); };
        
        function updateCCT() {
           const k = state.kelvin; const t = state.tint; document.getElementById('val-kelvin').innerText = k + "K"; document.getElementById('val-tint').innerText = t;
           const rgb = applyTint(kelvinToRgb(k), t); updateWhiteUI(rgb); activateStatic('CCT');
        }
        function updateWhiteUI(rgb) {
            state.whiteRgb = rgb;
            document.getElementById('input-white-r').value = Math.round(rgb.r); document.getElementById('val-white-r-input').value = Math.round(rgb.r); updateRangeStyle(document.getElementById('input-white-r'));
            document.getElementById('input-white-g').value = Math.round(rgb.g); document.getElementById('val-white-g-input').value = Math.round(rgb.g); updateRangeStyle(document.getElementById('input-white-g'));
            document.getElementById('input-white-b').value = Math.round(rgb.b); document.getElementById('val-white-b-input').value = Math.round(rgb.b); updateRangeStyle(document.getElementById('input-white-b'));
            document.getElementById('hex-input-white').value = rgbToHex(rgb.r, rgb.g, rgb.b);
        }
        function updateFromWhiteRGB() {
            const r = parseInt(document.getElementById('input-white-r').value); const g = parseInt(document.getElementById('input-white-g').value); const b = parseInt(document.getElementById('input-white-b').value);
            document.getElementById('val-white-r-input').value = r; document.getElementById('val-white-g-input').value = g; document.getElementById('val-white-b-input').value = b;
            state.whiteRgb = {r:r, g:g, b:b}; document.getElementById('hex-input-white').value = rgbToHex(r, g, b); activateStatic('CCT');
            updateRangeStyle(document.getElementById('input-white-r')); updateRangeStyle(document.getElementById('input-white-g')); updateRangeStyle(document.getElementById('input-white-b'));
        }
        ['input-white-r', 'input-white-g', 'input-white-b'].forEach(id => document.getElementById(id).addEventListener('input', updateFromWhiteRGB));
        document.getElementById('hex-input-white').addEventListener('change', e => { let hex = e.target.value; if(!hex.startsWith('#')) hex='#'+hex; const rgb = hexToRgb(hex); state.whiteRgb = rgb; updateWhiteUI(rgb); activateStatic('CCT'); });

        function updateRGBInputs(rgb) { 
            // FIX: On v√©rifie si la valeur est d√©finie au lieu d'utiliser "||" qui rejette le 0
            const r = Math.round(rgb[0] !== undefined ? rgb[0] : rgb.r);
            const g = Math.round(rgb[1] !== undefined ? rgb[1] : rgb.g);
            const b = Math.round(rgb[2] !== undefined ? rgb[2] : rgb.b);

            document.getElementById('input-r').value = r; 
            document.getElementById('val-r-input').value = r; 
            updateRangeStyle(document.getElementById('input-r'));
            
            document.getElementById('input-g').value = g; 
            document.getElementById('val-g-input').value = g; 
            updateRangeStyle(document.getElementById('input-g'));
            
            document.getElementById('input-b').value = b; 
            document.getElementById('val-b-input').value = b; 
            updateRangeStyle(document.getElementById('input-b'));
        }

        // --- COLLE CECI JUSTE APRES updateRGBInputs ---
        
        function updateFromRGB() {
             if (isWheelDrag) return; 

             const r = parseInt(document.getElementById('input-r').value) || 0; 
             const g = parseInt(document.getElementById('input-g').value) || 0; 
             const b = parseInt(document.getElementById('input-b').value) || 0;
             
             document.getElementById('val-r-input').value = r; 
             document.getElementById('val-g-input').value = g; 
             document.getElementById('val-b-input').value = b;
             
             updateRangeStyle(document.getElementById('input-r')); 
             updateRangeStyle(document.getElementById('input-g')); 
             updateRangeStyle(document.getElementById('input-b'));
             
             const hex = rgbToHex(r, g, b); 
             const hsv = rgbToHsv(r, g, b);
             
             // FIX: On ne change la teinte que si la couleur a de la saturation.
             // Cela √©vite que le curseur saute sur le ROUGE (0¬∞) quand on passe par le blanc/gris/noir.
             if (hsv.s > 0.5) { state.hue = hsv.h; }
             
             state.sat = hsv.s; 
             state.val = hsv.v;
             
             document.getElementById('hex-input').value = hex; 
             document.getElementById('input-sat').value = state.sat; 
             document.getElementById('val-sat-input').value = Math.round(state.sat);
             
             updateRangeStyle(document.getElementById('input-sat')); 
             updateCursorVisuals();
        }

        function updateWheel(e) {
            // Calculer les coordonn√©es globales pour le centrage (inclut bordures)
            const rect = wheel.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            // Calculer le rayon INTERNE (exclut la bordure noire)
            const radius = wheel.clientWidth / 2;
            
            if (radius <= 0) return;

            const x = e.touches ? e.touches[0].clientX : e.clientX; 
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            
            const dx = x - centerX; 
            const dy = y - centerY; 
            
            // On limite la distance au rayon interne uniquement
            const rawDist = Math.sqrt(dx*dx + dy*dy);
            const dist = Math.min(rawDist, radius);
            
            let ang = Math.atan2(dy, dx) * (180 / Math.PI); 
            if(ang < 0) ang += 360;
            
            state.hue = (ang + 90) % 360; 
            state.sat = Math.min(100, Math.max(0, (dist / radius) * 100)); 
            state.val = 100;
            
            document.getElementById('input-sat').value = Math.round(state.sat); 
            document.getElementById('val-sat-input').value = Math.round(state.sat); 
            updateRangeStyle(document.getElementById('input-sat'));
            
            updateCursorVisuals(); 
            
            const rgb = hsvToRgb(state.hue, state.sat, 100); 
            
            // S√©curit√© anti-bug
            if (isNaN(rgb[0]) || isNaN(rgb[1]) || isNaN(rgb[2])) return;

            hexInput.value = rgbToHex(rgb[0], rgb[1], rgb[2]); 
            updateRGBInputs(rgb); 
        }

                
        function updateCursorVisuals() {
            const container = document.getElementById('color-wheel'); 
            const cursor = document.getElementById('wheel-cursor'); 
            
            // Gestion du fond (Hublot)
            const wrapper = document.querySelector('.wheel-wrapper');
            // FIX: On utilise state.val au lieu de forcer 100 pour permettre le noir
            const bgRgb = hsvToRgb(state.hue, state.sat, state.val);
            if(wrapper) wrapper.style.backgroundColor = `rgb(${bgRgb[0]}, ${bgRgb[1]}, ${bgRgb[2]})`;

            // --- CORRECTION DU CENTRAGE ---

            // --- CORRECTION DU CENTRAGE ---
            // On utilise clientWidth qui donne la largeur INTERNE (la zone color√©e sans la bordure noire)
            // Le centre (radius) est donc exactement le milieu de la zone visible.
            const radius = container.clientWidth / 2;

            const rad = (state.hue - 90) * (Math.PI / 180); 
            
            // La distance s'adapte automatiquement au rayon interne
            // Saturation 100% ira exactement au bord de la couleur, sans toucher le noir
            const dist = (state.sat / 100) * radius;
            
            cursor.style.left = (radius + Math.cos(rad) * dist) + 'px'; 
            cursor.style.top = (radius + Math.sin(rad) * dist) + 'px';
        }
        
        window.addEventListener('resize', () => { if(state.mode === 'WHEEL') updateCursorVisuals(); });
        ['input-r', 'input-g', 'input-b'].forEach(id => { document.getElementById(id).addEventListener('input', () => { updateFromRGB(); activateStatic('WHEEL'); }); });

        const wheel = document.getElementById('color-wheel'); const hexInput = document.getElementById('hex-input');
        let isWheelDrag = false;
               
        hexInput.addEventListener('change', (e) => {
            let hex = e.target.value; if(!hex.startsWith('#')) hex = '#' + hex;
            const rgb = hexToRgb(hex); document.getElementById('input-r').value = rgb.r; document.getElementById('input-g').value = rgb.g; document.getElementById('input-b').value = rgb.b;
            updateFromRGB(); activateStatic('WHEEL');
        });
        
        updateCursorVisuals(); 
        wheel.addEventListener('mousedown', e => { isWheelDrag=true; activateStatic('WHEEL'); updateWheel(e); }); 
        window.addEventListener('mousemove', e => { if(isWheelDrag) { e.preventDefault(); updateWheel(e); } }); 
        window.addEventListener('mouseup', () => isWheelDrag=false);
        wheel.addEventListener('touchstart', e => { isWheelDrag=true; activateStatic('WHEEL'); updateWheel(e); }, {passive:false}); 
        window.addEventListener('touchmove', e => { if(isWheelDrag) { e.preventDefault(); updateWheel(e); } }, {passive:false}); 
        window.addEventListener('touchend', () => isWheelDrag=false);

        const panel = document.getElementById('main-panel'); const handle = document.getElementById('drag-handle'); 
        let isDrag=false, startX, startY, initL, initT;
        handle.addEventListener('mousedown', e => { 
            isDrag=true; startX=e.clientX; startY=e.clientY; panel.style.transition = 'none'; 
            const r=panel.getBoundingClientRect(); panel.style.left=r.left+'px'; panel.style.top=r.top+'px'; panel.style.transform='none'; initL=r.left; initT=r.top; 
        });
        window.addEventListener('mousemove', e => { if(isDrag){ panel.style.left=(initL+(e.clientX-startX))+'px'; panel.style.top=(initT+(e.clientY-startY))+'px'; } });
        window.addEventListener('mouseup', ()=> { if(isDrag) { isDrag=false; setTimeout(() => { panel.style.transition = 'opacity 0.3s, transform 0.3s'; }, 50); } });

        function initSliderStyles() { document.querySelectorAll('input[type=range]').forEach(el => updateRangeStyle(el)); }

        window.updateFxParam = (id, val) => {
            val = parseInt(val); state['fxParam'+id] = val;
            const label = document.getElementById(`val-fx-p${id}`); const input = document.getElementById(`input-fx-p${id}`);
            if(label) label.innerText = val + "%"; if(input) { input.value = val; updateRangeStyle(input); }
        };

        function syncUI() {
            document.getElementById('val-sat-input').value = Math.round(state.sat); 
            document.getElementById('val-kelvin').innerText = state.kelvin + "K"; document.getElementById('val-tint').innerText = state.tint;
            document.getElementById('val-speed-input').value = state.speed; document.getElementById('val-text-size').innerText = state.textSize + "%"; 
            document.getElementById('val-text-speed').innerText = state.textSpeed; document.getElementById('val-dimmer-input').value = state.dimmer;
            
            document.getElementById('input-sat').value = state.sat; document.getElementById('input-kelvin').value = state.kelvin; document.getElementById('input-tint').value = state.tint;
            document.getElementById('input-speed').value = state.speed; document.getElementById('input-text-size').value = state.textSize; 
            document.getElementById('input-text-speed').value = state.textSpeed; document.getElementById('input-dimmer').value = state.dimmer;
            
            const rgb = hsvToRgb(state.hue, state.sat, 100); updateRGBInputs(rgb); document.getElementById('hex-input').value = rgbToHex(rgb[0], rgb[1], rgb[2]);
            const wRgb = applyTint(kelvinToRgb(state.kelvin), state.tint); updateWhiteUI(wRgb);

            const gridInput = document.getElementById('input-grid-lvl'); gridInput.value = state.gridLevel; updateGridSlider(gridInput);
            const warpInput = document.getElementById('input-warp-lvl'); warpInput.value = state.warpLevel; updateWarpSlider(warpInput);
            const noiseInput = document.getElementById('input-noise-lvl'); noiseInput.value = state.noiseLevel; updateNoiseSlider(noiseInput);
            
            document.querySelectorAll('.preset-btn').forEach(btn => { btn.classList.remove('active'); if(parseInt(btn.innerText) === state.kelvin) btn.classList.add('active'); });
            const allCards = document.getElementById('master-fx-grid').querySelectorAll('.fx-card');
            allCards.forEach(c => c.classList.remove('active')); if(allCards[state.fxMode]) allCards[state.fxMode].classList.add('active');

            document.querySelectorAll('.map-btn').forEach(b => b.classList.remove('active-map'));
            const mapBtns = document.getElementById('matrix-pad-grid').querySelectorAll('.map-btn');
            if(state.mapMode === -1) { if (mapBtns[0]) mapBtns[0].classList.add('active-map'); } 
            else if(state.mapMode >= 0 && state.mapMode < MAPS.length) { if (mapBtns[state.mapMode + 1]) mapBtns[state.mapMode + 1].classList.add('active-map'); }

            updateMatrixDisplays();

            document.getElementById('text-content').value = state.textString; document.getElementById('input-text-color').value = state.textColor;
            document.getElementById('input-text-font').value = state.textFont; document.getElementById('input-text-effect').value = state.textEffect;
            const textLvlInput = document.getElementById('input-text-fx-lvl'); textLvlInput.value = state.textFxLvl; updateTextSlider();
            
            const textToggle = document.getElementById('btn-text-toggle');
            if(state.textOn) { textToggle.innerText = DICT[CURRENT_LANG].TEXT_ON; textToggle.classList.add('active'); } 
            else { textToggle.innerText = DICT[CURRENT_LANG].TEXT_OFF; textToggle.classList.remove('active'); }

            updatePaletteUI();
            if (document.fullscreenElement) document.querySelector('.fullscreen-btn').classList.add('active');
            initSliderStyles();
            [1, 2, 3].forEach(id => updateFxParam(id, state['fxParam'+id]));
            setTimeout(updateCursorVisuals, 50);
        }
        
        initSliderStyles();
        // 0-15 pour Cin√©ma, 16-31 pour Shnopia
        addFxToMasterGrid(CINEMA_FX, 0); addFxToMasterGrid(SHNOPIA_FX, 16);
        syncUI(); requestAnimationFrame(render);

        (function() {
            const counterEl = document.getElementById('global-counter');
            let localVisits = localStorage.getItem('shnopia_local_boots') || 0; localVisits++; localStorage.setItem('shnopia_local_boots', localVisits);
            const controller = new AbortController(); setTimeout(() => controller.abort(), 2000);
            fetch('https://api.counterapi.dev/v1/shnopia_sle/visits/up', { signal: controller.signal })
            .then(response => { if (!response.ok) throw new Error("API Error"); return response.json(); })
            .then(data => { counterEl.innerText = "NET: #" + data.count.toString().padStart(6, '0'); counterEl.style.color = "var(--lcd-on)"; })
            .catch(err => { counterEl.innerText = "LOC: #" + localVisits.toString().padStart(4, '0'); counterEl.style.color = "#ccaa00"; });
        })();

        window.triggerAction = (el, type) => {
            el.classList.add('flash'); setTimeout(() => el.classList.remove('flash'), 300);
            if(type === 'manual') { setTimeout(() => window.open('manual.html', '_blank'), 300); } 
            else if (type === 'mail') { setTimeout(() => window.location.href = "mailto:rossignol.p@gmail.com?subject=" + encodeURIComponent("A propos de Shnopia Light Engine"), 300); }
        };

        window.triggerDevMsg = (el) => {
            el.classList.add('flash'); setTimeout(() => el.classList.remove('flash'), 300);
            if (el.classList.contains('is-revealed')) { window.open("https://www.facebook.com/61584293050053", "_blank"); return; }
            el.classList.add('is-revealed'); 
            const title = el.querySelector('#dev-title'); const sub = el.querySelector('#dev-sub');
            title.style.transition = 'opacity 0.2s'; sub.style.transition = 'opacity 0.2s'; title.style.opacity = '0'; sub.style.opacity = '0';
            setTimeout(() => {
                title.style.display = 'none'; sub.innerHTML = "SUIVEZ LE PROJET SUR FACEBOOK :<br><span style='text-decoration:underline; font-size:10px;'>facebook.com/61584293050053</span><br><br>";
                sub.classList.add('dev-msg-active'); sub.style.flexDirection = 'column'; sub.style.opacity = '1';
            }, 300);
        };

        window.triggerDownload = (el) => { el.classList.add('flash'); setTimeout(()=>el.classList.remove('flash'), 500); return true; };

                const CODE_MAP = { m: 'mode', k: 'kelvin', t: 'tint', h: 'hue', s: 'sat', v: 'val', d: 'dimmer', s: 'speed', fm: 'fxMode', p1: 'fxParam1', p2: 'fxParam2', p3: 'fxParam3', pa: 'paletteActive', mm: 'mapMode', to: 'textOn', ts: 'textString', tsz: 'textSize', tsp: 'textSpeed', tc: 'textColor', tf: 'textFont', te: 'textEffect', tfl: 'textFxLvl', gl: 'gridLevel', wl: 'warpLevel', nl: 'noiseLevel' };

        function decodeShnopiaCode(str) {
            try {
                if (!str || !str.startsWith("SLE8:")) return null;
                const b64 = str.split("SLE8:")[1]; const json = decodeURIComponent(escape(window.atob(b64))); const mini = JSON.parse(json);
                let decodedState = {}; for (let key in mini) { if (CODE_MAP[key]) decodedState[CODE_MAP[key]] = mini[key]; }
                if (decodedState.gridLevel !== undefined) decodedState.gridActive = decodedState.gridLevel > 1;
                if (decodedState.warpLevel !== undefined) decodedState.warpActive = decodedState.warpLevel > 0;
                if (decodedState.noiseLevel !== undefined) decodedState.noiseActive = decodedState.noiseLevel > 0;
                return decodedState;
            } catch (e) { return null; }
        }

        function loadCode(str) {
            const newState = decodeShnopiaCode(str);
            if (newState) { Object.assign(state, newState); syncUI(); const btn = document.querySelector('.hide-btn'); if (btn) { const old = btn.innerHTML; btn.innerHTML = "üíæ CHARG√â!"; setTimeout(() => btn.innerHTML = old, 1500); } return true; } 
            else { alert("‚ùå ERREUR: Code corrompu."); return false; }
        }

        window.handleShnopiaCode = () => {
            const code = generateCode();
            const modal = document.getElementById('qr-modal-overlay'); const textArea = document.getElementById('code-text-area');
            textArea.value = code; modal.style.display = 'flex'; textArea.select();
        };

        window.closeQrModal = (force) => {
            if(force === true || force.target.id === 'qr-modal-overlay') {
                document.getElementById('qr-modal-overlay').style.display = 'none';
                const content = document.getElementById('code-text-area').value; const currentGenerated = generateCode();
                if(content && content.startsWith("SLE8:") && content !== currentGenerated) { loadCode(content); }
            }
        };

        window.copyCodeToClip = () => {
            const textArea = document.getElementById('code-text-area'); textArea.select(); document.execCommand('copy');
            const btn = document.querySelector('.qr-btn-copy'); const oldText = btn.innerText; btn.innerText = "COPI√â !"; setTimeout(() => btn.innerText = oldText, 1000);
        };

        window.pasteCodeFromClip = async () => {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('code-text-area').value = text;
                const btn = document.querySelector('.qr-btn-paste'); const oldText = btn.innerText; btn.innerText = "COLL√â !"; setTimeout(() => btn.innerText = oldText, 1000);
            } catch (err) {
                // Fallback si l'API clipboard est bloqu√©e (ex: context non s√©curis√©)
                const textArea = document.getElementById('code-text-area'); textArea.focus(); textArea.select();
                const btn = document.querySelector('.qr-btn-paste'); const oldText = btn.innerText; btn.innerText = "CTRL+V"; setTimeout(() => btn.innerText = oldText, 2000);
            }
        };

        window.autoRecordAll = async () => {
            const btn = document.querySelector('button[onclick="autoRecordAll()"]'); if(btn) btn.disabled = true;
            const originalState = JSON.parse(JSON.stringify(state)); const originalPad = selectedPadIndex;
            for(let i=0; i<LIVE_SLOTS; i++) {
                if(liveMemory[i]) {
                    if(btn) btn.innerText = `ENREGISTREMENT PAD ${i+1}/${LIVE_SLOTS}...`;
                    recallLive(i); await new Promise(r => setTimeout(r, 100));
                    const stream = canvas.captureStream(30); const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); const chunks = [];
                    recorder.ondataavailable = (e) => { if(e.data.size > 0) chunks.push(e.data); };
                    await new Promise((resolve) => {
                        recorder.onstop = () => {
                            const blob = new Blob(chunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob);
                            const pad = document.getElementById(`live-pad-${i}`); pad.innerHTML = ''; 
                            const video = document.createElement('video'); video.className = 'pad-video'; video.src = url; 
                            video.muted = true; video.loop = true; video.autoplay = true; video.playsInline = true;
                            pad.appendChild(video); video.play(); resolve(); 
                        };
                        recorder.start(); setTimeout(() => { recorder.stop(); }, 2000);
                    });
                }
            }
            if(originalPad >= 0) recallLive(originalPad); else Object.assign(state, originalState); 
            syncUI(); if(btn) { btn.innerText = "‚úÖ TERMIN√â"; btn.disabled = false; setTimeout(() => btn.innerText = "üé• G√âN√âRER LES PREVIEWS VID√âO (AUTO-REC)", 2000); }
        };

        function generateCode() {
            let mini = {}; for(let key in CODE_MAP) mini[key] = state[CODE_MAP[key]];
            const json = JSON.stringify(mini); const b64 = btoa(unescape(encodeURIComponent(json))); return "SLE8:" + b64;
        }

        function initMatrixPads() {
            const container = document.getElementById('matrix-pad-grid'); container.innerHTML = '';
            for (let gridIndex = 0; gridIndex < 12; gridIndex++) {
                const div = document.createElement('div'); div.className = 'map-btn';
                if (gridIndex === 0) {
                    div.id = 'matrix-off-btn';
                    div.onclick = () => setMapMode(0, div); div.innerHTML = `<span style="font-size:14px; margin-bottom:2px;">OFF</span><span style="font-size:9px; opacity:0.8;">(Mode HD)</span>`;
                } else {
                    const mapIndex = gridIndex - 1; 
                    if (mapIndex < MAPS.length) {
                        const map = MAPS[mapIndex];
                        if(map.name === "SET") {
                            div.onclick = showCustomMatrixModal; div.id = 'btn-set';
                            div.innerHTML = `<span style="font-size:14px; margin-bottom:2px;">SET</span><span id="set-display" class="map-set-display" style="font-size:9px;">Matrice ${map.w}x${map.h}</span>`;
                        } else {
                            div.onclick = () => setMapMode(gridIndex, div); 
                            div.innerHTML = `<span style="font-size:13px; margin-bottom:2px;">${map.name}</span><span style="font-size:9px; opacity:0.8;">Matrice ${map.w}x${map.h}</span>`;
                        }
                    } else {
                        div.onclick = () => { div.classList.add('active-map'); setTimeout(() => div.classList.remove('active-map'), 200); toggleMatrixDimension(); };
                        div.innerHTML = `<span style="font-size:14px; margin-bottom:2px;">ROTATE</span><span style="font-size:9px; opacity:0.8;">(Inverser W/H)</span>`;
                    }
                }
                container.appendChild(div);
            }
             const gridLvlInput = document.getElementById('input-grid-lvl');
             gridLvlInput.min = "-5"; gridLvlInput.max = "10"; state.gridLevel = 0; gridLvlInput.value = 0; updateRangeStyle(gridLvlInput);
             gridLvlInput.oninput = (el) => { state.gridLevel = parseInt(el.target.value); updateRangeStyle(el.target); updateMatrixDisplays(); };
        }

        function autoSelectRatio() {
            const screenW = window.screen.width; const screenH = window.screen.height; const ratio = screenW / screenH;
            let bestMatchIndex = 2; let minDiff = 100;
            [0, 1, 2, 3].forEach(i => { const mapRatio = MAPS[i].w / MAPS[i].h; const diff = Math.abs(ratio - mapRatio); if (diff < minDiff) { minDiff = diff; bestMatchIndex = i; } });
            setTimeout(() => { const pads = document.querySelectorAll('.map-btn'); const targetPadIndex = bestMatchIndex + 1; if(pads[targetPadIndex]) { setMapMode(targetPadIndex, pads[targetPadIndex]); } }, 100);
        }
        
        initMatrixPads(); autoSelectRatio(); updateMatrixDisplays(); initLiveGrid();
    
// --- GESTION DE LA SOURIS (ROULETTE) SUR LES SLIDERS ---
    function initWheelControl() {
        const sliders = document.querySelectorAll('input[type=range]');
        
        sliders.forEach(slider => {
            slider.addEventListener('wheel', (e) => {
                // Emp√™cher le scroll de la page
                e.preventDefault();

                // D√©terminer la direction (Haut = + / Bas = -)
                const direction = Math.sign(e.deltaY) * -1;
                
                // D√©finir le pas (step). 
                // Pour le Kelvin on avance de 50 par cran, sinon de 1 (ou selon l'attribut step)
                let step = 1;
                if (slider.id === 'input-kelvin') step = 50;
                else if (slider.step) step = parseFloat(slider.step);

                // Calculer la nouvelle valeur
                let currentVal = parseFloat(slider.value);
                let newVal = currentVal + (direction * step);

                // Appliquer les limites min/max
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                if (newVal < min) newVal = min;
                if (newVal > max) newVal = max;

                // Si la valeur change, on applique et on d√©clenche l'√©v√©nement
                if (slider.value != newVal) {
                    slider.value = newVal;
                    // D√©clenche l'√©v√©nement 'input' pour que les couleurs/canvas se mettent √† jour
                    slider.dispatchEvent(new Event('input'));
                }
            }, { passive: false }); // Important pour que preventDefault fonctionne
        });
    }

    // Lancer la fonction
    initWheelControl();

</script>
</body>
</html>
